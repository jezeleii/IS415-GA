---
title: "Take-Home Exercise 1"
author: "Jezelei Manangan"
date: "September 5, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

# 1.0 Overview

## 1.1 Objectives

-   Using appropriate function of sf and tidyverse packages, import and transform the downloaded armed conflict data and administrative boundary data into sf tibble data.frames.

-   Using the geospatial data sets prepared, derive quarterly KDE layers.

-   Using the geospatial data sets prepared, perform 2nd-Order Spatial Point Patterns Analysis.

-   Using the geospatial data sets prepared, derive quarterly spatio-temporal KDE layers.

-   Using the geospatial data sets prepared, perform 2nd-Order Spatio-temporal Point Patterns Analysis.

-   Using appropriate tmap functions, display the KDE and Spatio-temporal KDE layers on openstreetmap of Myanmar.

-   Describe the spatial patterns revealed by the KDE and Spatio-temporal KDE maps.

# 2.0 The Data

## 2.1 Packages Used

The table below provides a summary of the packages I've used for this exercise

+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**tidyverse**](https://www.tidyverse.org/)                                   | for performing data science tasks such as importing, wrangling and visualising data.                                                                                                                                                                                                                                                  |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | It contains the following packages used :                                                                                                                                                                                                                                                                                             |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **readr** for importing csv data,                                                                                                                                                                                                                                                                                                 |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **readxl** for importing Excel worksheet,                                                                                                                                                                                                                                                                                         |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **tidyr** for manipulating data,                                                                                                                                                                                                                                                                                                  |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **dplyr** for transforming data, and                                                                                                                                                                                                                                                                                              |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **ggplot2** for visualising data                                                                                                                                                                                                                                                                                                  |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**sf**](https://r-spatial.github.io/sf/index.html)                           | package provides functions to manage, processing, and manipulate **Simple Features**, a formal geospatial data standard that specifies a storage and access model of spatial geometries such as points, lines, and polygons.                                                                                                          |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html)           | which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API.                                                                                                                                                                             |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**spatstat**](https://spatstat.org/)                                         | has functions useful for Point Pattern Analysis                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**raster**](https://cran.r-project.org/web/packages/raster/)                 | reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster)                                                                                                                                                                                                                                                  |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**spNetwork**](https://cran.r-project.org/web/packages/spNetwork/index.html) | which provides functions to perform Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network. It also can be used to build spatial matrices (‘listw’ objects like in ‘spdep’ package) to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances. |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| sp                                                                            |                                                                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| dplyr                                                                         |                                                                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**sparr**](https://tilmandavies.github.io/sparr/index.html)                  | provides functions to estimate fixed and adaptive kernel-smoothed spatial relative risk surfaces via the density-ratio method and perform subsequent inference. Fixed-bandwidth spatiotemporal density and relative risk estimation is also supported                                                                                 |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| animation                                                                     |                                                                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

: The code chunk below installs and launches the R packages,

```{r}
pacman::p_load(tidyverse, sf, sp, tmap, spatstat, raster, spNetwork, RColorBrewer,dplyr, sparr,animation, magick)
```

## 2.2 Datasets Used

In response to the [background context](https://is415-ay2024-25t1.netlify.app/th_ex1) of the armed conflict happening in Myanmar, the exercise aims to discover the spatial and spatio-temporal distribution of armed conflict in Myanmar.

Upon further research, I've managed to come across an interesting resource which maps out the [Warscapes in Myanmar](https://myanmar.iiss.org/). It illustrates the variations in the type of conflict inflicted in different zones of the country

### Aspatial Data

-   `MYNMAR.CSV` dataset derived from [Armed Conflict Location & Event Data Project (ACLED)](https://acleddata.com/), a non-profit organization collecting, analyzing and mapping data on political violence and protest events around the world. (Limited to Jan 2021 - June 2024)

### Geospatial

The following datasets were obtained from: <https://data.humdata.org/organization/mimu>

-   Myanmar Country Boundaries MIMU

-   Myanmar State_Region Boundaries MIMU

-   Points of Interest from **OpenStreetMap,** depicting different categories of features mapped by the OSM community. It depicts various categories such as : public services and infrastructure, emergency and safety locations, amenities etc.

This additional dataset from OpenStreetMap is crucial for analyzing armed conflict in Myanmar as it provides detailed geographic information on key locations such as public services, infrastructure, and emergency and safety sites. Understanding the distribution of these points of interest helps in assessing the impact of conflict on civilian infrastructure, access to essential services, and the safety of affected populations. Furthermore, it may aid in planning humanitarian assistance, evacuation routes, and monitoring areas of strategic importance during the conflict through data insights.

For the purposes of this exercise, we will focus on the State/Region boundaries, seeing as the conflict is generally explored in this manner (as inferred from the given references in the Take Home Exercise Overview). This is represented by the first administrative level (admin1). Myanmar is divided into 7 states and 7 regions (plus the Union Territory of Naypyidaw).

These boundaries are politically and administratively significant. Different **states** (e.g., Kachin, Rakhine, Shan) and **regions** have distinct ethnic compositions and different conflict dynamics, making this level critical for understanding broader conflict patterns.

# 3.0 Geospatial Data Wrangling

## 3.1 Importing Spatial Data

### 1. Myanmar CSV

Using read_csv to import the data in the `MYANMAR.CSV` file, which is the ACLED Dataset detailing armed conflict in Myanmar:

```{r}
armed_conflict_data <- read_csv("data/aspatial/2021-01-01-2024-06-30-Myanmar.csv")
```

Check and transform the CRS of the ACLED Dataset:

```{r}
colnames(armed_conflict_data)
```

```{r}
armed_conflict <- st_as_sf(armed_conflict_data, coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(armed_conflict, crs=32647)
```

### 2. Country, State, Region, District Boundaries

Using the st_read function, we will import data from the State & Region Sub-boundary dataset to visualize Myanmar's landscape. We will focus our analysis on the State_Region Level (Admin1)

```{r}
state_region_sf <-  st_read(dsn="data/geospatial/stateRegion", layer 
="mmr_polbnda_adm1_250k_mimu_1") %>% 
  st_transform(myanmar_sf, crs=32647)
```

```{r}
district_sf <- st_read(dsn="data/geospatial/district", layer 
="mmr_polbnda_adm2_250k_mimu") %>% 
  st_transform(myanmar_sf, crs=32647)
```

After importing the dataset, we will plot to see the boundaries of the State & Regions of Myanmar. The **`plot()`** function is used to plot the geometry of the **`sf`** object. The **`st_geometry()`** function is used to extract the geometry of the **`state_region_sf`** object.

```{r fig.width=12, fig.height=10}
tmap_mode("plot")

tm_shape(state_region_sf) + 
  tm_polygons() + 
  tm_text("ST", size =0.9, just="center")

tm_layout(frame=FALSE)
```

### 3. Points of Interest

From here on out, we will denote points-of-interest as POI.

I will load the corresponding shapefile:

```{r}
poi_sf <- st_read(dsn = "data/geospatial/pointsOfInterest", layer = "hotosm_mmr_points_of_interest_points_shp") %>%
  st_set_crs(4326) %>%  
  st_transform(crs = 32647)  
```

```{r}
st_crs(poi_sf)
```

```{r}
colnames(poi_sf)
```

Based on the unique amenities, those that would be relevant in analyzing armed conflict effects in Myanmar would be : "hospital" , "refugee_site", "Health centre" , "clinic":

```{r}
poi_sf <- poi_sf %>% 
  mutate(amenity = str_to_lower(amenity)) %>% 
  filter(amenity %in% c("refugee_site", "hospital", "health center")) %>% 
  dplyr::select(name_en, amenity, geometry)

poi_sf
```

```{r}
tmap_mode('plot')

tm_shape(state_region_sf) +
  tm_polygons(alpha=0.5) + 
  tm_shape(poi_sf) +
  tm_dots(col = "amenity", palette = "Set1",
          title="Amenity Type") +
  tm_layout(main.title = "Distribution of Healthcare Infrastructure & Amenities", 
            main.title.position = c("center", "top")
  ) + 
  tm_layout(legend.outside=TRUE)

```

## 3.2 Data Preparation

Before a thematic map can be prepared, we have to prepare a data table which includes the variables event types, focused on : Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians.

```{r}
str(armed_conflict)
```

Here is a visual overview of the 4 different types of Armed Conflict (based on event_types) :

```{r fig.width=12, fig.height=10}
tmap_mode("plot")

tm_shape(state_region_sf) + 
  tm_borders(col = "black") + 
  tm_shape(armed_conflict) + 
  tm_dots(col = "event_type", palette = "Set1", size = 0.01, alpha = 0.5) +
  tm_facets(by = "event_type") + 
  tm_layout(title = "Armed Conflict in Myanmar (Jan 2021 - Jun 2024)", 
            legend.outside = TRUE) +
  tm_legend(title = "Event Type")
```

From the plots above, we see that armed conflict even types seem to concentrate in the North-west region, particularly at the boundary of Sagaing, Mandalay and Magwe state, which we will zoom in on.

In order to group and have a sensing of the effects of armed conflict, we will aggregate based on fatalities to see a quick overview as well as their state (administrative boundary 1) :

```{r}
armed_conflict_fatalities <- armed_conflict %>% 
  group_by(admin1, event_type) %>% 
  summarize(total_fatalities = sum(fatalities, na.rm=TRUE)) %>% 
  ungroup() %>% 
  
  #Summarize fatalities based on the administrative boundary (stateRegion)
  group_by(admin1) %>% 
  mutate(total_fatalities_admin1 = sum(total_fatalities)) %>% 
  ungroup() %>% 
  
  #Arrange admin1 by descending order of fatalities and then the event type 
  arrange(desc(total_fatalities_admin1), admin1, desc(total_fatalities)) 

armed_conflict_fatalities
```

Based on the above result, we see that the fatalities are concentrated in are concentrated in these 3 states: Sagaing, Magway and Mandalay.

The code chunk below explores the data further:

```{r}
armed_conflict_fatalities_by_event_type <- armed_conflict %>% 
  group_by(event_type) %>% 
  summarize(total_fatalities = sum(fatalities, na.rm=TRUE), 
            event_count = n()) %>% 
  ungroup() %>% 
  arrange(desc(total_fatalities))

armed_conflict_fatalities_by_event_type
```

Before doing so, let's explore the nuances in the naming convention to understand a potential reason why conflict arises:

```{r}
area_names <- state_region_sf %>% 
  distinct(ST_RG) %>% 
  pull(ST_RG)

area_names
```

### Key Differences

-   **State**:

    -   Represents areas predominantly inhabited by ethnic minorities, each with their own cultural and historical significance.

    -   Often involved in ethnic conflicts, seeking more autonomy.

-   **Region**:

    -   Represents the Bamar-majority areas, which have more economic and political power.

    -   Typically less conflict-prone compared to states.

-   **Union Territory**:

    -   A special administrative area directly controlled by the central government (e.g., the capital region).

    -   No local parliament or legislative autonomy.

## 3.3 Subsetting the data:

### 3.3.1 Data Processing of subsetted dataset - `MYANMAR.CSV`

We'll now process the data to see the corresponding fatalities with the different event types mentioned above, **Battles, Explosions/Remote violence, Strategic developments and Violence against civilians**.

From this point forward, we will focus on the event_type of 'Battles' and sub_event_type of 'Armed Clash' as it would be interesting to analyse given that it has the most event counts and fatalities as aggregated in the code above:

-   Since we are interested in deriving the quarterly KDE layers, we will convert the event_date column (currently in \[chr\] format), into a Date object that can be used for further analysis.

```{r}
armed_conflict_sf <- armed_conflict %>%
  filter(event_type == "Battles") %>% 
  filter(admin1 %in% c("Sagaing", "Magway", "Mandalay")) %>% 
  dplyr::select(1:3, 5:8, 11, 15, 19, 20, 27, 29, 30)
```

Save the intermediate dataset to rds:

```{r}
write_rds(armed_conflict_sf, "data/rds/armed_conflict_sf.rds")
```

We change the CRS to 32647 given that it is in the North Western Zone of Myanmar:

```{r}
armed_conflict_sf <- read_rds("data/rds/armed_conflict_sf.rds") %>% 
  st_transform(crs = 32647) 
```

```{r}
head(armed_conflict_sf)
```

```{r}
armed_conflict_sf <- armed_conflict_sf %>% 
  mutate(event_date = as.Date(event_date, format = "%d %B %Y")) %>% 
  mutate(quarter = paste0("Q", quarter(event_date), " ", year(event_date)))

armed_conflict_sf
```

```{r}
armed_conflict_battles <- armed_conflict_sf %>% 
  group_by(event_type, sub_event_type) %>% 
  summarize(total_fatalities = sum(fatalities, na.rm=TRUE), 
            event_count = n()) %>% 
    filter(event_type == "Battles") %>% 
    ungroup() 

armed_conflict_battles
```

```{r}
total_deaths <- armed_conflict %>% summarize(total_fatalities = sum(fatalities, na.rm=TRUE),
            event_count = n())

total_deaths
```

Out of 54091 deaths for the whole of Myanmar for Jan 2021 - Jun 2024, encompassing all event_types and sub_event_types recorded, deaths from event_type == "Battles" , specifically the sub_event_type of "Armed clash" has lead to 34581 deaths in the states of Myanmar alone, accounting for \~63.9% of deaths.

### 3.3.1 Data Processing of subsetted dataset - `State_Region_sf`

```{r}
state3_sf <- state_region_sf %>% 
  filter(ST %in% c("Sagaing", "Magway", "Mandalay")) %>% 
  st_transform(crs = 32647)

state3_sf
```

```{r}
plot(state3_sf)
```

## 3.4 Filtering down to Battles, Armed Clash

### 3.4.1 Analyzing Densities based on fatalities and event_count

Calculating area of each state in km\^2:

```{r}
state3_sf <- state3_sf %>% 
  mutate(area_km2 = st_area(geometry) / 1e6)
```

Density for Fatalities & Event_count in the area:

```{r}
event_density_data <- armed_conflict_sf %>%
  group_by(admin1) %>%
  summarise(
    total_events = n(),               
    total_fatalities = sum(fatalities, na.rm = TRUE)  
  ) %>% 
  ungroup()
```

Merge the event data with the state-level area data

```{r}
event_density_data
```

```{r}
event_density_data <- state3_sf %>%
  st_join(event_density_data, by = "admin1")
```

```{r}
colnames(event_density_data)
```

```{r}
event_density_data <- event_density_data %>%
  mutate(
    event_density = total_events / area_km2,         
    fatality_density = total_fatalities / area_km2    
  )
```

```{r}
tmap_mode("plot")

# Plot event density
tm_shape(event_density_data) +
  tm_polygons("event_density", title = "Event Density (Events/km²)") +
  tm_layout(legend.outside = TRUE)

# Plot fatality density
tm_shape(event_density_data) +
  tm_polygons("fatality_density", title = "Fatality Density (Fatalities/km²)") +
  tm_layout(legend.outside = TRUE)
```

### 3.4.1 Subsetting the data:

```{r}
armed_conflict_sf
```

```{r}
armed_clash_sf <- armed_conflict_sf %>% 
  filter(event_type == "Battles", sub_event_type =="Armed clash") %>% 
  group_by(quarter, event_type, sub_event_type, admin1, geometry, event_date) %>% 
  summarize(
      `FATALITIES` = sum(fatalities, na.rm=TRUE), 
      event_count = n()
  ) %>% 
  ungroup()

armed_clash_sf
```

## 3.5 Converting sf Object to sp Object

```{r}
armed_clash_sp <- as(armed_clash_sf, "Spatial")
state3_sp <- as(state3_sf, "Spatial")
```

```{r}
colnames(armed_clash_sf)
```

```{r}
unique_coordinates <- armed_clash_sf %>%
  summarise(unique_count = n_distinct(geometry))  # Directly on geometry column

# For total event count
total_armed_clash_count <- armed_clash_sf %>% 
  summarise(event_count = sum(event_count, na.rm = TRUE))

# Print results
print(unique_coordinates)
print(total_armed_clash_count)  
```

Out of 4681 Armed Clash conflict events, only 1547 unique coordinate points are recorded, indicating the that armed clashes occurred more than once for the coordinate points in general.

## 3.6 Converting sp Object to spatstat's ppp Format

```{r}
glimpse(armed_clash_sp)
```

```{r}
armed_clash_ppp <- as.ppp(armed_clash_sf)
```

**Warning: (Regarding duplicates)** In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are *simple*, that is, that the points cannot be coincident.

```{r}
plot(armed_clash_ppp)
```

## 3.7 Handling Duplicated Points

We check for duplication in the ppp object using the code chunk below. Before processing, we need to account for the fact that we have divided the data into quarters, which would result in the event_types at the same location being treated as separate points, but spatstat recognizing them as duplicates as they share the exact same coordinates.

```{r}
any(duplicated(armed_clash_ppp))
```

```{r}
sum(multiplicity(armed_clash_ppp) > 1)
```

To account for the number of locations which have more than one point event, we can use the code chunk below:

```{r}
coords <- st_coordinates(armed_clash_sf)
coords_df <- as.data.frame(coords)

location_counts <- coords_df %>% 
  group_by(X,Y) %>% 
  summarize(count = n()) %>% 
  ungroup()

locations_with_multiple_events <- location_counts %>% 
  filter(count > 1)

count_locations_with_multiple_events <- nrow(locations_with_multiple_events)
count_locations_with_multiple_events
```

Out of 1547 unique coordinate points, 515 have more than one conflict events occuring throughout the time period of Jan 2021 - Jun 2024, which could account for the 2503 duplicate count above.

```{r}
#| eval: false
tmap_mode('view')

tm_shape(armed_clash_sf) + 
  tm_dots(alpha = 0.7, size = 0.01)
```

```{r}
tmap_mode('plot')
```

## 3.8 Spotting Duplicate points from the map shown

To address the duplicate points, which largely arises due to the temporal aspect of the data we will use Jittering (adding a small perturbation to the duplicate points so that they do not occupy the exact same space)

The code chunk below implements the jittering approach.

```{r}
armed_clash_jitter <- rjitter(armed_clash_ppp, 
                                 retry=TRUE, 
                                 nsim=1, 
                                 drop=TRUE)
```

Check for duplicated points in the data:

```{r}
any(duplicated(armed_clash_jitter))
```

# 4.0 Creating *owin* object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Myanmar (Sagaing, Madway, Mandalay) boundary. In **spatstat**, an object called ***owin*** is specially designed to represent this polygonal region.

The code chunk below is used to covert state_3 SpatialPolygon object into owin object of **spatstat:**

```{r}
states3_owin <- as.owin(state3_sf)
```

```{r}
class(states3_owin)
```

The output object can be displayed by using plot():

```{r}
plot(states3_owin)
```

## 4.1 Combining point events object and owin object

In the next step of geospatial data wrangling, we extract armed conflict (armed clash as a subset of Battles) events located within Myanmar using this code chunk:

```{r}
armed_clash_myn_ppp <- armed_clash_ppp[states3_owin]
```

The output combined both the point and polygon feature in one ppp object class as shown below:

```{r}
plot(armed_clash_myn_ppp, cex = 0.4, main="Spatial Distribution of Battles (Armed Clash) in Myanmar")
```

```{r}
summary(armed_clash_myn_ppp)
```

# 5.0 1st Order Spatial Point Pattern Analysis

## 5.1 Kernel Density Estimation

This section with perform first-order SPPA and focus on :

1.  Deriving KDE for visualizing and exploring the intensity of point processes
2.  Perform Confirmatory Spatial Point Patterns Analysis by using Nearest Neighbour Statistics

### 5.1.1 Computing KDE using automatic bandwidth selection method

The code chunk below computes a kernel density by using the following configurations of [*density()*](https://rdrr.io/cran/spatstat/man/density.ppp.html) of **spatstat**:

-   [*bw.diggle()*](https://rdrr.io/cran/spatstat/man/bw.diggle.html) automatic bandwidth selection method. Other recommended methods are [*bw.CvL()*](https://rdrr.io/cran/spatstat/man/bw.CvL.html), [*bw.scott()*](https://rdrr.io/cran/spatstat/man/bw.scott.html) or [*bw.ppl()*](https://rdrr.io/cran/spatstat/man/bw.ppl.html).

-   The smoothing kernel used is *gaussian*, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.

```{r}
kde_armed_clash_myn_bw <- density(armed_clash_myn_ppp, 
                                     sigma=bw.diggle, 
                                     edge=TRUE,
                                     kernel="gaussian")
```

```{r}
plot(kde_armed_clash_myn_bw)
```

```{r}
sigma_diggle <- bw.diggle(armed_clash_myn_ppp)
sigma_diggle
```

### 5.1.2 Rescalling KDE values

In the code chunk below, we need to rescale.ppp() unit from meter to kilometer to prevent interference in the scale as well as the distortion of the bandwith values:

```{r}
armed_clash_myn_ppp.km <- rescale.ppp(armed_clash_myn_ppp, 1000, "km")
```

We re-run density() using the rescaled data and plot the output KDE map: (Note the difference between \_bw and .bw to denote scaled data)

```{r}
kde_armed_clash_myn.bw <- density(armed_clash_myn_ppp.km,
                                     sigma=bw.diggle, 
                                     edge=TRUE, 
                                     kernel="gaussian")

plot(kde_armed_clash_myn.bw)
```

```{r}
sigma_diggle <- bw.diggle(armed_clash_myn_ppp.km)
sigma_diggle
```

# 6.0 Comparing Spatial Point Patterns across Quarterly KDEs

Before proceeding, we take a look at how the fatalities and event_counts are aggregated across quarters:

```{r}
quarterly_summary <- armed_clash_sf %>%
  group_by(quarter) %>%  # Group by quarter
  summarise(
    total_fatalities = sum(FATALITIES, na.rm = TRUE), 
    event_count = n()                               
  ) %>% 
  ungroup()

print(quarterly_summary)
```

## **6.1 Working with different automatic bandwidth methods**

Beside *bw.diggle()*, there are three other **spatstat** functions can be used to determine the bandwidth, they are: *bw.CvL()*, *bw.scott()*, and *bw.ppl()*.

Let us take a look at the bandwidth return by these automatic bandwidth calculation methods by using the code chunk below.

```{r}
bw.CvL(armed_clash_myn_ppp.km)
```

```{r}
bw.scott(armed_clash_myn_ppp.km)
```

```{r}
bw.ppl(armed_clash_myn_ppp.km)
```

```{r}
bw.diggle(armed_clash_myn_ppp.km)
```

The code chunk beow will be used to compare the output of using the different methods.

```{r}
par(mfrow=c(2,2))
plot(density(armed_clash_myn_ppp.km,
             sigma=bw.CvL,
             edge=TRUE,
             kernel="gaussian", 
             main="3 States CvL"))

plot(density(armed_clash_myn_ppp.km,
             sigma=bw.scott,
             edge=TRUE,
             kernel="gaussian", 
             main="3 States Scott"))

plot(density(armed_clash_myn_ppp.km,
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian", 
             main="3 States ppl"))

plot(density(armed_clash_myn_ppp.km,
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian", 
             main="3 States diggleL"))
```

**Interpretation:** To summarize given the expectation of multiple clusters in th Myanmar conflict data, I'll be predominantly utilizing bw.ppl(), well-suited for capturing multiple clusters without overfitting or underfitting, Baddeley et al. (2016). In the case where tighter, isolated clusters are preferred, bw.diggle() will be the sigma used.

## **6.2 Working with different kernel methods**

By default, the kernel method used in *density.ppp()* is *gaussian*. But there are three other options, namely: Epanechnikov, Quartic and Dics.

The code chunk below will be used to compute three more kernel density estimations by using these three kernel function.

```{r}
par(mfrow=c(2,2))
plot(density(armed_clash_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(armed_clash_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(armed_clash_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(armed_clash_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## 6.2 Fixed vs Adaptive bandwidth for KDE

The choice between automatic and adaptive bandwidth depends on the objectives and nature of our analysis.

| Fixed Bandwidth                                                                                   | Adaptive Bandwidth                                                                                                                                                     |
|---------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Offers Consistency across Space: Uniform smoothing across the entire study area.                  | Varying Spatial Densities: Showing significant differences in conflict event densities (urban, rural ares), adaptive bandwidth could give a more nuanced understanding |
| General Hotspot Detection: To identify overall hotspots or conflict zones without too much detail | Local Hotspot Detection                                                                                                                                                |

: 6.2.1 **Computing KDE by using fixed bandwidth**

Based on our earlier analysis, we received a sigma value of 6. which results in minimal smoothing, meaning the KDE will show more localized patterns, however, this could lead to overfitting, where small clusters are exaggerated and conflict points are more prone to misinterpretation.

Currently, as I am unsure of what sigma degree to use, a good starting point would be to calculate the average or median Nearest Neighbour distance between points and use that as an initial value:

```{r}
mean_distance <- mean(nndist(armed_clash_myn_ppp.km))

par(mfrow=c(1,2))
kde_diggle <- density.ppp(armed_clash_myn_ppp.km, sigma=bw.diggle)
kde_ppl<- density.ppp(armed_clash_myn_ppp.km, sigma=bw.ppl)
plot(kde_diggle)
plot(kde_ppl)
```

### **6.2.2 Computing KDE by using adaptive bandwidth**

```{r}
kde_armed_clash_myn_adaptive <- adaptive.density(armed_clash_myn_ppp.km, 
                                                 method="kernel")
plot(kde_armed_clash_myn_adaptive)
```

## 6.3 Fixed Bandwith for Quarterly KDE Analysis

### Key Considerations for KDE Comparison Across Quarters:

1.  **Consistency**: For the KDEs to be comparable across different quarters, you need to use the **same sigma** for all quarters. This ensures that the degree of smoothing is consistent across the time periods, allowing you to make fair comparisons of density patterns over time.

2.  **Scale of Patterns**: The chosen sigma should be large enough to reveal the relevant spatial patterns without introducing too much noise (from a very small sigma) or losing too much detail (from a very large sigma).

| Initial Sigma Value (0.07)                                                                                                                                                           |                                                                                                                                                                                                       | Mean Distance (1.6)                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                       |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Advantages                                                                                                                                                                           | Disadvantages                                                                                                                                                                                         | Advantages                                                                                                                                                                                                                                                                                                                                                                 | Disadvantages                                                                                                                                                         |
| Captures **local detail**: This smaller sigma will emphasize fine-grained, local patterns, showing small clusters of events that may otherwise be smoothed over with a larger sigma. | **Too small for larger trends**: A sigma of 0.18 may result in overfitting, where the KDE highlights every small cluster or isolated event.                                                           | **Good balance of local and global patterns**: A sigma of 1.6 km (based on average nearest neighbor distance) strikes a balance between capturing local clusters and revealing broader spatial trends. It smooths out small noise while still showing meaningful clusters.                                                                                                 | **Less local detail**: While the 1.6 km sigma is a good balance, it may not capture very small-scale, localized patterns that might be relevant in specific analyses. |
| **Good for high-detail analysis**: If your goal is to observe very specific spatial variations within each quarter, this smaller sigma might be more suitable.                       | **Difficult for comparisons**: A very small sigma might highlight differences in individual points rather than overall trends, making it harder to compare the general distributions across quarters. | **Better for comparisons**: Since this sigma is derived from the overall spacing of points in your dataset, it reflects a more general spatial structure. This makes it more suitable for **comparing KDE patterns across different quarters**, as it ensures that the bandwidth is appropriate for both sparse and dense data, without overemphasizing small differences. |                                                                                                                                                                       |

Content adapted from Luc Anselin Spatial Econometrics.

Based on this analysis, I am more inclined to go with the mean distance calculated for a Fixed Bandwidth, which we will use to compare Battles (Armed clash) across different quarters.

Simple visualizations through graphs can help us get a better sense of the temporal aspect of when these armed clashes occurred. Since we are dealing with time:

```{r}
armed_clash_long <- armed_clash_sf %>%
  arrange(desc(FATALITIES)) %>% 
  pivot_longer(cols = c(FATALITIES, event_count), 
               names_to = "measure",             
               values_to = "value")
```

```{r}
ggplot(armed_clash_long, aes(x = value, 
                             y = factor(quarter, levels = sort(unique(quarter))))) + 
  geom_bar(stat = "identity", position = "dodge", fill = "black") +  
  geom_text(data = armed_clash_long %>%
              group_by(quarter, measure) %>% 
              filter(value == max(value)),  
            aes(label = round(value, 1)),  
            position = position_dodge(width = 0.9), 
            vjust = 0.5,  
            hjust = 4.0,  
            size = 3,    
            color = "white") + 
  facet_wrap(~measure, scales = "free_x") + 
  labs(title = "Total Fatalities and Event Count by Event Type per Quarter", 
       x = "Value", 
       y = "Quarter") + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
quarters <- unique(marks(armed_clash_myn_ppp))

par(mfrow = c(2,2))

for (q in quarters){
  quarter_ppp <- armed_clash_myn_ppp[marks(armed_clash_myn_ppp)==q]
  plot(quarter_ppp, main=paste("Spatial Distribution for", q), cex = 0.5)
}
```

# 7.0 Computing Quarterly KDE

By using the code chunk below, we can extract the armed_conflict points using the quarter marks to proceed with analysis. Additionally, we have to

1.  combine the myanmar_states_owin object and

2.  rescale the data as done previously

```{r}
# 2021 - Subset Armed Clash Jitter
q1_2021_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q1 2021"]
q2_2021_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q2 2021"]
q3_2021_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q3 2021"]
q4_2021_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q4 2021"]

# 2022 - Subset Armed Clash Jitter
q1_2022_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q1 2022"]
q2_2022_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q2 2022"]
q3_2022_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q3 2022"]
q4_2022_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q4 2022"]

# 2023 - Subset Armed Clash Jitter 
q1_2023_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q1 2023"]
q2_2023_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q2 2023"]
q3_2023_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q3 2023"]
q4_2023_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q4 2023"]

# 2024 - Subset Armed Clash Jitter 
q1_2024_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q1 2024"]
q2_2024_jitter <- armed_clash_jitter[armed_clash_jitter$marks == "Q2 2024"]
```

## 7.1 Combining Quarterly Armed Conflict Points and with the owin Object

```{r}
q1_2021_ppp <- q1_2021_jitter[states3_owin]
q2_2021_ppp <- q2_2021_jitter[states3_owin]
q3_2021_ppp <- q3_2021_jitter[states3_owin]
q4_2021_ppp <- q4_2021_jitter[states3_owin]

# For 2022
q1_2022_ppp <- q1_2022_jitter[states3_owin]
q2_2022_ppp <- q2_2022_jitter[states3_owin]
q3_2022_ppp <- q3_2022_jitter[states3_owin]
q4_2022_ppp <- q4_2022_jitter[states3_owin]

# For 2023
q1_2023_ppp <- q1_2023_jitter[states3_owin]
q2_2023_ppp <- q2_2023_jitter[states3_owin]
q3_2023_ppp <- q3_2023_jitter[states3_owin]
q4_2023_ppp <- q4_2023_jitter[states3_owin]

# For 2024
q1_2024_ppp <- q1_2024_jitter[states3_owin]
q2_2024_ppp <- q2_2024_jitter[states3_owin]
```

## 7.2 Rescale.ppp()

```{r}
# For 2021
q1_2021_ppp.km = rescale.ppp(q1_2021_ppp, 1000, "km")
q2_2021_ppp.km = rescale.ppp(q2_2021_ppp, 1000, "km")
q3_2021_ppp.km = rescale.ppp(q3_2021_ppp, 1000, "km")
q4_2021_ppp.km = rescale.ppp(q4_2021_ppp, 1000, "km")

# For 2022
q1_2022_ppp.km = rescale.ppp(q1_2022_ppp, 1000, "km")
q2_2022_ppp.km = rescale.ppp(q2_2022_ppp, 1000, "km")
q3_2022_ppp.km = rescale.ppp(q3_2022_ppp, 1000, "km")
q4_2022_ppp.km = rescale.ppp(q4_2022_ppp, 1000, "km")

# For 2023
q1_2023_ppp.km = rescale.ppp(q1_2023_ppp, 1000, "km")
q2_2023_ppp.km = rescale.ppp(q2_2023_ppp, 1000, "km")
q3_2023_ppp.km = rescale.ppp(q3_2023_ppp, 1000, "km")
q4_2023_ppp.km = rescale.ppp(q4_2023_ppp, 1000, "km")

# For 2024
q1_2024_ppp.km = rescale.ppp(q1_2024_ppp, 1000, "km")
q2_2024_ppp.km = rescale.ppp(q2_2024_ppp, 1000, "km")
```

In the code chunk below, we will compute the KDE of each quarter of each year. ***bw.diggle*** method is used to derive the bandwidth of each KDE:

```{r fig.width=10, fig.height=12}

par(mfrow = c(4, 4), mar = c(2, 2, 2, 2)) 

# 2021 plots
plot(density(q1_2021_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q1 2021")

plot(density(q2_2021_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q2 2021")


plot(density(q3_2021_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q3 2021")

plot(density(q4_2021_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q4 2021")


# 2022 plots
plot(density(q1_2022_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q1 2022")

plot(density(q2_2022_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q2 2022")


plot(density(q3_2022_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q3 2022")

plot(density(q4_2022_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q4 2022")

# 2023 plots
plot(density(q1_2023_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q1 2023")

plot(density(q2_2023_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q2 2023")


plot(density(q3_2023_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q3 2023")

plot(density(q4_2023_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q4 2023")

# 2024 plots
plot(density(q1_2024_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q1 2024")

plot(density(q2_2024_ppp.km, 
             sigma=bw.ppl,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q2 2024")
```

# 8.0 Nearest Neighbours Analysis:

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using [*clarkevans.test()*](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **statspat**.

The test hypotheses are:

Ho = The distribution of Armed Clashes are randomly distributed.

H1= The distribution of Armed Clashes are not randomly distributed.

The 95% confident interval will be used.

To maintain temporal consistency in analysis, we will compare the same quarter across multiple years to detec changes over time and evaluate whether the spatial distribution of armed clashes follow a seasonal or cyclical pattern.

## 8.1 Testing Spatial Point Patterns using Clark and Evans Test

```{r}
clarkevans.test(armed_clash_myn_ppp.km,
                correction="none",
                clipregion="states3_owin",
                alternative=c("two.sided"),
                nsim=99)
```

**Interpretation:**

-   The **R-value** (0.37315) suggests that the points (armed clashes) are **clustered**—events tend to occur near each other.

-   The **p-value** (extremely low) provides very strong evidence against the null hypothesis of randomness. Thus, we conclude that the distribution of armed clashes is **not random** but instead shows a statistically significant **clustered** pattern.

### 8.1.1 Clark and Evans Test: Q2 2021

```{r}
clarkevans.test(q2_2021_ppp.km,
                correction="none",
                clipregion="states3_owin",
                alternative=c("two.sided"),
                nsim=99)
```

### 8.1.2 Clark and Evans Test: Q2 2022

```{r}
clarkevans.test(q2_2022_ppp.km,
                correction="none",
                clipregion="states3_owin",
                alternative=c("two.sided"),
                nsim=99)
```

### 8.1.3 Clark and Evans Test: Q2 2023

```{r}
clarkevans.test(q2_2023_ppp.km,
                correction="none",
                clipregion="states3_owin",
                alternative=c("two.sided"),
                nsim=99)
```

### 8.1.4 Clark and Evans Test: Q2 2024

```{r}
clarkevans.test(q2_2024_ppp.km,
                correction="none",
                clipregion="states3_owin",
                alternative=c("two.sided"),
                nsim=99)
```

### Reasons to account for the observed pattern:

Based on the R-value, where lower R values indicate strong clustering, it follows the reasons below:

1.  [**Escalation of Conflict in the hotspot Area**](https://www.britannica.com/event/2021-Myanmar-coup-d-etat)**:** From 2021 onwards, the area of study has recently experience a military coup in February 2021, which was concentrated as the Tatmadaw (military) cracked down on urban areas and strategic areas. These mentioned states were areas where civilian resistance was particularly strong.
2.  **Implication of Dispersion:** This observation is further evidence by the quarterly summation of the deaths by state, where for the same quarters observed below: Q4 2021 - Q2 2022, there was a stark increase in the total_fatalities and event_count, marking the amplification of armed clash battles in the region, accounting for the strong clustering patterns observed from Q2 2021 which showed the strongest clustering out of the 4 quarters assessed and eventual distribution of the conflict towards other areas.

```{r}
quarterly_summary %>% 
  arrange(desc(total_fatalities))
```

```{r}
quarterly_summary_by_state <- armed_clash_sf %>%
  group_by(quarter, admin1) %>%  # Group by quarter
  summarise(
    total_fatalities = sum(FATALITIES, na.rm = TRUE), 
    event_count = n()                               
  ) %>% 
  ungroup() %>% 
  arrange(desc(total_fatalities))

print(quarterly_summary_by_state)
```

# 9.0 2nd Order Spatial Point Patterns Analysis

# 9.1 Extracting the Study Area

The code chunk below will be used to extract the target planning areas.

```{r}
district_sf <- district_sf %>% 
  filter(ST %in% c("Sagaing", "Magway", "Mandalay"))
```

```{r}
colnames(state3_sf)
```

```{r}
sagaing <- state3_sf %>% 
  filter(ST == "Sagaing")

magway <- state3_sf %>% 
  filter(ST == "Magway")

mandalay <- state3_sf %>% 
  filter(ST == "Mandalay")
```

```{r}
quarterly_summary_by_state
```

## 9.2 Converting sf to owin objects

```{r}
sagaing_owin = as.owin(sagaing)
magway_owin = as.owin(magway)
mandalay_owin = as.owin(mandalay)
```

```{r}
par(mfrow=c(1,3))
plot(sagaing_owin)
plot(magway_owin)
plot(mandalay_owin)
```

### 9.2.1 Combining armed clash points and the study area

By using the code chunk below, we are able to extract armed clashes that is within the specific region to do our analysis later on.

```{r}
armed_clash_sng_ppp = armed_clash_jitter[sagaing_owin]
armed_clash_mgy_ppp = armed_clash_jitter[magway_owin]
armed_clash_mnd_ppp = armed_clash_jitter[mandalay_owin]
```

Next, *rescale()* function is used to trasnform the unit of measurement from metre to kilometre.

```{r}
armed_clash_sng.km = rescale(armed_clash_sng_ppp, 1000, "km")
armed_clash_mgy.km = rescale(armed_clash_mgy_ppp, 1000, "km")
armed_clash_mnd.km = rescale(armed_clash_mnd_ppp, 1000, "km")
```

The code chunk below is used to plot these 3 study areas and the locations of the battles (armed clashes).

```{r}
par(mfrow=c(1,3))
plot(armed_clash_sng.km, main="Sagaing")
plot(armed_clash_mgy.km, main="Magway")
plot(armed_clash_mnd.km, main="Mandalay")
```

# **9.5 Second-order Spatial Point Patterns Analysis**

Based on the following code Chunk , we will focus our 2nd Point Pattern Analaysis on Sagaing, to see the distribution of the armed conflict and its interaction based on the location

```{r}
quarterly_summary_by_state
```

```{r}
reference_date <- min(armed_clash_sf$event_date, na.rm = TRUE)

armed_clash_year_sf <- armed_clash_sf %>%
  mutate(dayYear = yday(event_date),  # Day of the year
         monthNum = month(event_date),  # Numeric month
         monthFac = month(event_date, label = TRUE, abbr = FALSE),  # Factor for months
         yearMonth = interval(reference_date, event_date) %/% months(1) + 1) %>%
  filter(admin1 == "Sagaing")
armed_clash_year_sf
```

```{r}
armed_clash_sagaing <- armed_clash_sf %>% 
  filter(admin1 == "Sagaing")
```

## 9.6 **Analysing Spatial Point Process Using G-Function**

The G function measures the distribution of the distances from an arbitrary event to its nearest event. In this section, I compute the G-function estimation by using [*Gest()*](https://rdrr.io/cran/spatstat/man/Gest.html) of **spatstat** package. Additionally, I perform Monte Carlo simulation test using [*envelope()*](https://rdrr.io/cran/spatstat/man/envelope.html) of **spatstat** package.

### 9.6.1 Computing G-function estimation

```{r}
G_SNG = Gest(armed_clash_sng_ppp, correction = "best")
plot(G_SNG)
```

### 9.6.2 Performing Complete Spatial Randomness Test

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of armed clashes in Sagaing are randomly distributed.

H1= The distribution of armed clashes in Sagaing are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with G-fucntion

```{r}
G_SNG.csr <- envelope(armed_clash_sng_ppp, Gest, nsim = 99)
```

```{r}
plot(G_SNG.csr)
```

### 9.7 **Analysing Spatial Point Process Using F-Function**

The F function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape.In this section, I compute the F-function estimation by using [Fest()](https://rdrr.io/cran/spatstat/man/Gest.html) of **spatstat** package. Additionally, I perform Monte Carlo simulation test using [*envelope()*](https://rdrr.io/cran/spatstat/man/envelope.html) of **spatstat** package.

### 9.7.1 Computing F-function estimation

```{r}
F_SNG = Fest(armed_clash_sng_ppp, correction="best")
plot(F_SNG)
```

### 9.7.2 Performing Complete Spatial Randomness Test

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of armed clashes in Sagaing are randomly distributed.

H1= The distribution of armed clashes in Sagaing are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with F-fucntion

```{r}
F_SNG.csr <- envelope(armed_clash_sng_ppp, Fest, correction = "all", nsim = 99)
```

```{r}
plot(F_SNG.csr)
```

## 9.8 **Analysing Spatial Point Process Using K-Function**

### 9.8.1 Computing K-function estimation

```{r}
#| eval: false
K_SNG = Kest(armed_clash_sng_ppp, correction = "Ripley")
plot(K_SNG, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```
![](images/ksng.png)

### 9.8.2 Performing Complete Spatial Randomness Test

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of armed clashes in Sagaing are randomly distributed.

H1= The distribution of armed clashes in Sagaing are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with K-fucntion

```{r}
#| eval: false
K_SNG.csr <- envelope(armed_clash_sng_ppp, Kest, nsim = 30, rank = 1, glocal=TRUE)
```

```{r}
#| eval: false
plot(K_SNG.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```
![](images/ksngcsr.png)

## 9.9 **Analysing Spatial Point Process Using L-Function**

### 9.9.1 Computing L-function estimation

```{r}
#| eval: false
L_SNG = Lest(armed_clash_sng_ppp, correction = "Ripley")
plot(L_SNG, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)")
```
![](images/lsng.png)
### 9.8.2 Performing Complete Spatial Randomness Test

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of armed clashes in Sagaing are randomly distributed.

H1= The distribution of armed clashes in Sagaing are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with L-fucntion

```{r}
#| eval: false
L_SNG.csr <- envelope(armed_clash_sng_ppp, Lest, nsim = 30, rank = 1, glocal=TRUE)
```

```{r}
#| eval: false
plot(L_SNG.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```
![](images/lsngcsr.png)
# 10. Spatio-Temporal Point Pattern Analysis

```{r}
healthcare_sng <- st_intersection(poi_sf,sagaing)
```

```{r}
class(armed_clash_sagaing)
class(healthcare_sng)
```

```{r}
tmap_mode('view')

tm_basemap(server="OpenStreetMap.HOT") + 
tm_basemap(server="Esri.WorldImagery") + 

tm_shape(sagaing) + 
  tm_polygons(alpha=0.3) + 

tm_shape(armed_clash_sagaing) + 
  tm_dots(col = "red", size = 0.01, alpha = 0.6, title = "Armed Battles") + 

tm_shape(healthcare_sng) + 
  tm_dots(col = "darkgreen", size = 0.2, alpha = 0.7, title = "Hospitals") + 

tm_layout(
  main.title = "Depiction of Armed Clashes in Sagaing",  # Title text
  main.title.position = c("center", "top"),  
  legend.position = c("right", "bottom"),  
  legend.outside = TRUE,  
  legend.outside.position = "bottom"  
) + 

#
tm_view(bbox = st_bbox(sagaing)) 
```

```{r}
tmap_mode('plot')
```

## 10.1 Visualizing geographic distribution of Armed Clashes by Quarter:

```{r}
tm_shape(sagaing) + 
  tm_polygons(alpha=0.3) + 
tm_shape(armed_clash_sagaing) + 
  tm_dots(size = 0.1, alpha = 0.5) + 
tm_facets(by="quarter", 
          free.coords=FALSE,
          drop.units = TRUE)
```

## Interesting points to note: Article by Think Global Health: [Healthcare has become a Battleground](https://www.thinkglobalhealth.org/article/myanmar-health-care-has-become-battleground)

Along with the quarterly visualization of the armed clashes, we see a corresponding fixation of attacks on the Southern point of the Sagaing, near the border of two other states in conflict (Madway and Mandalay). According to the article by Think Global Health:

> ### **Attacks on Health Care in Myanmar, 2021 – 2023**
>
> Myanmar's health system is under attack countrywide, with the greatest number of attacks taking place in the Sagaing, Mandalay, and Yangon regions.
>
> According to [Insecurity Insight](https://insecurityinsight.org/), a nonprofit group collecting data on conflicts worldwide, nearly 1,200 attacks on health-care workers and facilities have taken place in the three years since the coup. Doctors, aid workers, and other medical personnel have been detained and arrested, targeted for allegedly taking care of protestors or participating in the civil disobedience movement (CDM).  

```{r}
quarterly_summary_sagaing <- quarterly_summary_by_state %>% 
  filter(admin1 == "Sagaing")
quarterly_summary_sagaing  
```

Coincidentally (or not), the quarters with the higest number of recorded fatalities fall between Q4 2021 - Q3 2022, where we will focus the computation of STKDE

```{r}
armed_clash_sagaing
```

## 10.2 **Computing STKDE by Quarter**

**Creating: Q1 2021 - Q2 2024 using the interval() function**

Because **ppp** object only accept numerical or character as mark. The code chunk below is used to convert data type of *acq_date* to numeric.

```{r}
armed_clash_sf
```

```{r}
nrow(armed_clash_sf)
```

```{r}
reference_date <- min(armed_clash_sf$event_date, na.rm = TRUE)

armed_clash_year_sf <- armed_clash_sf %>%
  mutate(quarter = quarter(event_date)) %>%  
  mutate(year = year(event_date)) %>% 
  mutate(quarterInterval = (year - 2021) * 4 + quarter) %>%   
  filter(admin1 == "Sagaing")


armed_clash_year_sf
```

### 10.2.1 Creating ppp object

In the code chunk below, dayYear field is included in the output ppp object.

```{r}
summary(armed_clash_year_sf$quarterInterval)
```

```{r}
armed_clash_quarter_ppp <- armed_clash_year_sf %>% 
  dplyr::select(quarterInterval) 
```

```{r}
armed_clash_quarter_ppp <- as.ppp(armed_clash_quarter_ppp)
armed_clash_quarter_ppp
```

### **10.2.2 Including Owin object**

Next, code chunk below is used to combine the ppp object and the owin object.

```{r}
sagaing_quarter_owin <- armed_clash_quarter_ppp[sagaing_owin]
summary(sagaing_quarter_owin)
```

```{r}
plot(sagaing_quarter_owin)
```

Before proceeding, we can utilize `BOOT.spattemp()`. It support bandwidth selection for standalone spatiotemporal density/intensity based on bootstrap estimation of the MISE, providing an isotropic scalar spatial bandwidth and a scalar temporal bandwidth.

Code chunk below uses `BOOT.spattemp()` to determine both the spatial bandwidth and the scalar temporal bandwidth.

```{r}
set.seed(1234)
BOOT.spattemp_result <- BOOT.spattemp(sagaing_quarter_owin)
BOOT.spattemp_result
```

```{r}
kde_quarter <- spattemp.density(sagaing_quarter_owin,
                             h=BOOT.spattemp_result[1] ,
                             lambda=BOOT.spattemp_result[2])
summary(kde_quarter)
```

### 10.2.3 **Plotting the output spatio-temporal KDE**

```{r}
tims <- 1:14

quarter_labels <- c("Q1 2021", "Q2 2021", "Q3 2021", "Q4 2021",
                    "Q1 2022", "Q2 2022", "Q3 2022", "Q4 2022",
                    "Q1 2023", "Q2 2023", "Q3 2023", "Q4 2023",
                    "Q1 2024", "Q2 2024")

n_cols <-4 
batch_size <- 2
n_batches <- ceiling(length(tims)/batch_size)

for (b in 1:n_batches){
  start <- (b-1) * batch_size + 1
  end <- min(b * batch_size, length(tims))
  
  current_tims <- tims[start:end]
  
  par(mfrow=c(3,4), mar=c(2,2,2,2))
  
  for(i in current_tims){
    plot(kde_quarter, i,
         override.par=FALSE,
         fix.range=TRUE,
         main = paste(quarter_labels[i]))
  }
}
```

```{r}
#| eval: false
temp_gif <- "armed_clash.gif"

# Check if the GIF already exists
if (!file.exists(temp_gif)) {
  # If the GIF doesn't exist, create and save it
  saveGIF({
    for(i in tims){
      plot(kde_quarter, i, 
           override.par=FALSE, 
           fix.range=TRUE,
           main=paste('KDE at', quarter_labels[i]))
    }
  }, movie.name = temp_gif, interval = 0.01, ani.width=700, ani.height=500)
} else {
  # If the GIF already exists, skip the saving process
  message("GIF already exists, skipping save.")
}
```

![](images/armed_clash.gif)

## 10.3 Saving Intermediate Datasets:

```{r}
#| eval: false
write_rds(healthcare_sng, "data/rds/healthcare_sng.rds")
write_rds(quarterly_summary, "data/rds/quarterly_summary.rds")
write_rds(quarterly_summary_by_state, "data/rds/quarterly_summary_by_state.rds")
write_rds(state3_sf, "data/rds/state3_sf.rds")
write_rds(event_density_data, "data/rds/event_density_data.rds")
```

# **11.0 Conclusion**

In this take-home exercise, we explored the **spatial and spatio-temporal point patterns** of armed conflict in Myanmar from January 2021 to June 2024, with a specific focus on **Sagaing**, **Magway**, and **Mandalay** states/regions. The analysis employed various geospatial methods to derive insights from the data, including **Kernel Density Estimation (KDE)**, **Second-order Spatial Point Pattern Analysis**, and **Spatio-temporal KDE (STKDE)**.

## **Key Findings:**

1.  **Clustering of Armed Clashes**:

    -   Within **Q4 2021 to Q2 2022**, with **R-values** indicating a highly clustered distribution of conflict events. This clustering is particularly evident in Sagaing, Mandalay, and Magway, where much of the conflict was concentrated.

    -   The clustering can be attributed to the ongoing civil resistance following the military coup in Myanmar in 2021, with Sagaing experiencing heavily intense conflicts. This has prompted me to research further, finding that: 

        -   The area is prone to natural disasters, being located at the ‘Sagaing fault’ and is already a natural hotspot for refugee / displaced individuals due to the socio-economic plight it has faced, as part of the ‘Dry Zone’ 

        -   [Military Conscription](https://www.frontiermyanmar.net/en/conscription-or-conflict-dry-zone-draft-dodgers-come-home/) drives has ‘provoked reverse migration, pushing young men who fled Myanmar’s war-torn Dry Zone to give up their livellihoods and risk their lives to return home’ 

2.  **Kernel Density Estimation**:

    -   KDE analysis allowed us to visualize the intensity of conflict over time. Using **fixed bandwidth** (e.g., bw.ppl()), we observed that while the intensity of conflict was concentrated in certain regions, particularly in **Sagaing**, there was a gradual dispersion of conflict events over time into neighboring regions such as Magway and Mandalay.

    -   The choice of bandwidth (sigma) and kernel function was important for interpreting both local and broader trends in armed clashes. The **Gaussian kernel** was effective in showing overall trends, while smaller sigmas captured finer details, especially in high-density areas. Initially, I actually went with bw.diggle instead of bw.ppl bandwidth as I thought bw.diggle() is always the best choice for detecting clusters, and bw.ppl is better for smoothing over broader areas. However, this interpretation may be overly simplistic. 

        -   Going by bw.diggle, I obtained a really small sigma value which might have been a sign of overfitting. Furthermore, because of the plotting and the movement of the conflict over time, we ought to expect multiple clsuter, which implied bw.ppl was a better fit. 

3.  **Spatio-temporal KDE**:

    -   The **STKDE** provided a nuanced view of how conflict events evolved quarter by quarter, confirming that some periods saw a stark increase in fatalities, such as **Q4 2021 through Q2 2022**.

    -   The temporal analysis highlighted the **cyclical nature** of the conflict, with periods of intense violence followed by temporary dispersions or shifts in conflict zones.

4.  **2nd-Order Spatial Point Pattern Analysis**:

    -   The use of **G-, F-, K-, and L-functions** provided further confirmation of the **non-random** distribution of armed clashes. These functions indicated significant spatial interaction among the conflict points, suggesting that the locations of armed clashes were influenced by proximity to other events, reflecting the **complex nature of the conflict. 2nd Point Pattern Analysis allowed me to research further on the conflicting factors that affected (random) spatial distribution of armed conflict, and found the unfortunate but deliberate choice to target civilian institutions like hospitals.**

5.  **Healthcare as a Battleground**:

    -   By overlaying **points of interest (POI)** such as hospitals and healthcare facilities onto the map, we observed that many clashes occurred near key civilian infrastructure. This aligns with findings that **healthcare has become a battleground** in Myanmar, particularly in Sagaing and surrounding regions. Attacks on healthcare facilities have not only disrupted medical services but also contributed to the broader humanitarian crisis in the region.
