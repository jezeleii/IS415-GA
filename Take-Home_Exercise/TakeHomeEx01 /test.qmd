---
title: "Take-Home Exercise 2"
author: "Jezelei Manangan"
date: "September 5, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

```{r}
pacman::p_load(tidyverse, sf, sp, tmap, spatstat, raster, spNetwork, RColorBrewer, viridis,lubridate, dplyr)
```

```{r}
armed_conflict_data <- read_csv("data/aspatial/2021-01-01-2024-06-30-Myanmar.csv")
```

```{r}
armed_conflict_sf <- st_as_sf(armed_conflict_data, coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(armed_conflict_sf, crs=32647)
```

```{r}
st_crs(armed_conflict_sf)
```

State & Region Boundaries

```{r}
state_region_sf <-  st_read(dsn="data/geospatial/stateRegion", layer 
="mmr_polbnda_adm1_250k_mimu_1") %>% 
  st_transform(myanmar_sf, crs=32647)
```

POI SF:

```{r}
poi_sf <- st_read(dsn = "data/geospatial/pointsOfInterest", layer = "hotosm_mmr_points_of_interest_points_shp") %>%
  st_set_crs(4326) %>%   # Set CRS to WGS 84 (EPSG:4326) if missing
  st_transform(crs = 32647)  # Transform to UTM Zone 47N (EPSG:32647)

```

```{r}
armed_conflict_fatalities <- armed_conflict_sf %>% 
  group_by(event_type, sub_event_type) %>% 
  summarise(total_fatalities = sum(fatalities, na.rm=TRUE))
```

```{r}
armed_conflict_quartered <- armed_conflict_sf %>% 
  mutate(event_date = as.Date(event_date, format = "%d %B %Y")) %>% 
  mutate(quarter = paste0("Q", quarter(event_date), " ", year(event_date))) %>% 
  group_by(quarter, event_type) %>% 
  arrange(timestamp) %>% 
  summarize(
    `FATALITIES` = sum(fatalities, na.rm=TRUE),
    event_count = n()) %>% 
  ungroup()
```

```{r}
# Define the file path for saving
file_path <- "armed_conflict_quartered.csv"

# Check if the file already exists
if (!file.exists(file_path)) {
  # If the file does not exist, save the dataset
  write.csv(armed_conflict_quartered, file_path, row.names = FALSE)
  cat("File saved as", file_path, "\n")
} else {
  # If the file already exists, print a message
  cat("File", file_path, "already exists. Skipping save operation.\n")
}
```

converting sf to sp object

```{r}
armed_conflict <- as(armed_conflict_quartered, "Spatial")
state_region <- as(state_region_sf, "Spatial")
```

```{r}
unique_coordinates <- armed_conflict_sf %>% 
  summarise(unique_count = n_distinct(geometry))

unique_event_id_count <- armed_conflict_sf %>% 
  summarize(unique_geom = n_distinct(event_id_cnty))

print(unique_coordinates)
print(unique_event_id_count)
```

converting sp object to spatstat's pp format

```{r}
armed_conflict_ppp <- as.ppp(st_coordinates(armed_conflict))
```

# 7.0 1st Order Spatial Point Pattern Analysis

## 7.1 Kernel Density Estimation

This section with perform first-order SPPA and focus on :

1.  Deriving KDE for visualizing and exploring the intensity of point processes
2.  Perform Confirmatory Spatial Point Patterns Analysis by using Nearest Neighbour Statistics

### 7.1.1 Computing KDE using automatic bandwidth selection method

\*Here, we account for the fact that we need to rescale.ppp() unit from meter to km to prevent interference in the scale:

```{r}
acled_myn_ppp.km <- rescale.ppp(acled_myn_ppp, 1000, 'km')
```

```{r}
kde_myn.bw <- density(acled_myn_ppp.km, 
                      sigma=bw.diggle, 
                      edge=TRUE, 
                      kernel="gaussian")
```

The plot function of Base R is used to display the KDE derived

```{r}
plot(kde_myn.bw)
```

We will retrieve the bandwidth used to compute the KDE:

```{r}
bw <- bw.diggle(acled_myn_ppp)
bw
```

## 7.2 Working with Different Automatic Bandwidth Methods

Exploring the different automatic bandwidth methods

1.  bw.diggle()
2.  bw.CvL()
3.  bw.scott()
4.  bw.ppl()

```{r}
bw.CvL(acled_myn_ppp.km)
```

```{r}
bw.scott(acled_myn_ppp.km)
```

The code chunk below is used to compare the output of using bw.diggle and bw.ppl methods

```{r}
kde_myn.ppl <- density(acled_myn_ppp.km, 
                       sigma=bw.ppl, 
                       edge=TRUE, 
                       kernel="gaussian")

par(mfrow=c(1,2))
plot(kde_myn.bw, main="bw.diggle")
plot(kde_myn.ppl, main="bw.ppl")
```

### 7.3 Working with different Kernel Methods

The code chunk below will be used to compute 3 more KDEs by using the other three kernel functions, namely: Epanechnikov, Quartic and Discs:

```{r}
par(mfrow=c(2,2))
plot(density(acled_myn_ppp.km,
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian ")
plot(density(acled_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(acled_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(acled_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## Computing KDE using adaptive bandwidth

density.adaptive()

```{r}
kde_myn_adaptive <- adaptive.density(acled_myn_ppp.km, method="kernel")
plot(kde_myn_adaptive)
```

### Converting KDE output into Grid object

### Converting Gridded KDE Output into Raster

```{r}
kde_myn_bw_raster <- raster(kde_myn.bw)
```

```{r}
kde_myn_bw_raster
```

### assigning projection systems

```{r}
projection(kde_myn_bw_raster) <- CRS("+init=EPSG:32647")
kde_myn_bw_raster
```

### Visualizing the output in tmap

```{r}
tm_shape(kde_myn_bw_raster) + 
  tm_raster("layer", palette="viridis") + 
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

# Comparing Spatial Point Patterns across Quarterly KDE

## Extracting the Study Area

The code chunk below will be used to extract the target quarter periods

```{r}
q1
```

## 7.2 Working with Different Automatic Bandwidth Methods

This section explores the different automatic bandwidth methods:

1.  bw.diggle()
2.  bw.CvL()
3.  bw.scott()
4.  bw.ppl()

```{r}
bw.CvL(armed_conflict_myn_ppp.km)
```

```{r}
bw.scott(armed_conflict_myn_ppp.km)
```

The code chunk below is used to compare the output of using bw.diggle and bw.ppl methods

```{r}
kde_armed_conflict_myn.ppl <- density(armed_conflict_myn_ppp.km, 
                       sigma=bw.ppl, 
                       edge=TRUE, 
                       kernel="gaussian")

par(mfrow=c(1,2))
plot(kde_armed_conflict_myn.bw, main="bw.diggle")
plot(kde_armed_conflict_myn.ppl, main="bw.ppl")
```

### 7.3 Working with different Kernel Methods

The code chunk below will be used to compute 3 more KDEs by using the other three kernel functions, namely: Epanechnikov, Quartic and Discs:

```{r}
par(mfrow=c(2,2))
plot(density(armed_conflict_myn_ppp.km,
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian ")
plot(density(armed_conflict_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(armed_conflict_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(armed_conflict_myn_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

# 8.0 Fixed and Adaptive KDE

```{r}

# Kernel Density Estimation for jittered points in 2021
# KDE for Q1 2021
plot(myanmar_states_owin, main = "KDE Q1 2021 - Jittered")
Q1_2021_kde <- density(q1_2021_jitter)
plot(Q1_2021_kde, add = TRUE)

# KDE for Q2 2021
plot(myanmar_states_owin, main = "KDE Q2 2021 - Jittered")
Q2_2021_kde <- density(q2_2021_jitter)
plot(Q2_2021_kde, add = TRUE)

# KDE for Q3 2021
plot(myanmar_states_owin, main = "KDE Q3 2021 - Jittered")
Q3_2021_kde <- density(q3_2021_jitter)
plot(Q3_2021_kde, add = TRUE)

# KDE for Q4 2021
plot(myanmar_states_owin, main = "KDE Q4 2021 - Jittered")
Q4_2021_kde <- density(q4_2021_jitter)
plot(Q4_2021_kde, add = TRUE)

### 2022 ###

# Subset jittered points by quarter for 2022
q1_2022_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q1 2022"]
q2_2022_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q2 2022"]
q3_2022_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q3 2022"]
q4_2022_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q4 2022"]

# Kernel Density Estimation for jittered points in 2022
# KDE for Q1 2022
plot(myanmar_states_owin, main = "KDE Q1 2022 - Jittered")
Q1_2022_kde <- density(q1_2022_jitter)
plot(Q1_2022_kde, add = TRUE)

# KDE for Q2 2022
plot(myanmar_states_owin, main = "KDE Q2 2022 - Jittered")
Q2_2022_kde <- density(q2_2022_jitter)
plot(Q2_2022_kde, add = TRUE)

# KDE for Q3 2022
plot(myanmar_states_owin, main = "KDE Q3 2022 - Jittered")
Q3_2022_kde <- density(q3_2022_jitter)
plot(Q3_2022_kde, add = TRUE)

# KDE for Q4 2022
plot(myanmar_states_owin, main = "KDE Q4 2022 - Jittered")
Q4_2022_kde <- density(q4_2022_jitter)
plot(Q4_2022_kde, add = TRUE)

### 2023 ###

# Subset jittered points by quarter for 2023
q1_2023_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q1 2023"]
q2_2023_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q2 2023"]
q3_2023_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q3 2023"]
q4_2023_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q4 2023"]

# Kernel Density Estimation for jittered points in 2023
# KDE for Q1 2023
plot(myanmar_states_owin, main = "KDE Q1 2023 - Jittered")
Q1_2023_kde <- density(q1_2023_jitter)
plot(Q1_2023_kde, add = TRUE)

# KDE for Q2 2023
plot(myanmar_states_owin, main = "KDE Q2 2023 - Jittered")
Q2_2023_kde <- density(q2_2023_jitter)
plot(Q2_2023_kde, add = TRUE)

# KDE for Q3 2023
plot(myanmar_states_owin, main = "KDE Q3 2023 - Jittered")
Q3_2023_kde <- density(q3_2023_jitter)
plot(Q3_2023_kde, add = TRUE)

# KDE for Q4 2023
plot(myanmar_states_owin, main = "KDE Q4 2023 - Jittered")
Q4_2023_kde <- density(q4_2023_jitter)
plot(Q4_2023_kde, add = TRUE)

### 2024 ###

# Subset jittered points by quarter for 2024
q1_2024_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q1 2024"]
q2_2024_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q2 2024"]

# Kernel Density Estimation for jittered points in 2024
# KDE for Q1 2024
plot(myanmar_states_owin, main = "KDE Q1 2024 - Jittered")
Q1_2024_kde <- density(q1_2024_jitter)
plot(Q1_2024_kde, add = TRUE)

# KDE for Q2 2024
plot(myanmar_states_owin, main = "KDE Q2 2024 - Jittered")
Q2_2024_kde <- density(q2_2024_jitter)
plot(Q2_2024_kde, add = TRUE)
```
