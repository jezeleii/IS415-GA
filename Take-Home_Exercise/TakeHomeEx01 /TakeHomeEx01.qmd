---
title: "Take-Home Exercise 2"
author: "Jezelei Manangan"
date: "September 5, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
---

# 1.0 Overview

## 1.1 Objectives

-   Using appropriate function of sf and tidyverse packages, import and transform the downloaded armed conflict data and administrative boundary data into sf tibble data.frames.

-   Using the geospatial data sets prepared, derive quarterly KDE layers.

-   Using the geospatial data sets prepared, perform 2nd-Order Spatial Point Patterns Analysis.

-   Using the geospatial data sets prepared, derive quarterly spatio-temporal KDE layers.

-   Using the geospatial data sets prepared, perform 2nd-Order Spatio-temporal Point Patterns Analysis.

-   Using appropriate tmap functions, display the KDE and Spatio-temporal KDE layers on openstreetmap of Myanmar.

-   Describe the spatial patterns revealed by the KDE and Spatio-temporal KDE maps.

# 2.0 The Data

## 2.1 Packages Used

The table below provides a summary of the packages I've used for this exercise

+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**tidyverse**](https://www.tidyverse.org/)                                   | for performing data science tasks such as importing, wrangling and visualising data.                                                                                                                                                                                                                                                  |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | It contains the following packages used :                                                                                                                                                                                                                                                                                             |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **readr** for importing csv data,                                                                                                                                                                                                                                                                                                 |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **readxl** for importing Excel worksheet,                                                                                                                                                                                                                                                                                         |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **tidyr** for manipulating data,                                                                                                                                                                                                                                                                                                  |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **dplyr** for transforming data, and                                                                                                                                                                                                                                                                                              |
|                                                                               |                                                                                                                                                                                                                                                                                                                                       |
|                                                                               | -   **ggplot2** for visualising data                                                                                                                                                                                                                                                                                                  |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**sf**](https://r-spatial.github.io/sf/index.html)                           | package provides functions to manage, processing, and manipulate **Simple Features**, a formal geospatial data standard that specifies a storage and access model of spatial geometries such as points, lines, and polygons.                                                                                                          |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html)           | which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API.                                                                                                                                                                             |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**spatstat**](https://spatstat.org/)                                         | has functions useful for Point Pattern Analysis                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**raster**](https://cran.r-project.org/web/packages/raster/)                 | reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster)                                                                                                                                                                                                                                                  |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| [**spNetwork**](https://cran.r-project.org/web/packages/spNetwork/index.html) | which provides functions to perform Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network. It also can be used to build spatial matrices (‘listw’ objects like in ‘spdep’ package) to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances. |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| RColorBrewer                                                                  |                                                                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Viridis                                                                       |                                                                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| lubridate                                                                     |                                                                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| dplyr                                                                         |                                                                                                                                                                                                                                                                                                                                       |
+-------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

In this Take-Home Exercise, I'm using the above packages (covered in class), and have added some for further analysis :

-   smoothr:

-   RColorBrewer

-   gifski

The code chunk below installs and launches the R packages,

```{r}
pacman::p_load(tidyverse, sf, sp, tmap, spatstat, raster, spNetwork, RColorBrewer, viridis,lubridate, dplyr)
```

## 2.2 Datasets Used

In response to the [background context](https://is415-ay2024-25t1.netlify.app/th_ex1) of the armed conflict happening in Myanmar, the exercise aims to discover the spatial and spatio-temporal distribution of armed conflict in Myanmar.

Upon further research, I've managed to come across an interesting resource which maps out the [Warscapes in Myanmar](https://myanmar.iiss.org/). It illustrates the variations in the type of conflict inflicted in different zones of the country

### Aspatial Data

-   `MYNMAR.CSV` dataset derived from [Armed Conflict Location & Event Data Project (ACLED)](https://acleddata.com/), a non-profit organization collecting, analyzing and mapping data on political violence and protest events around the world. (Limited to Jan 2021 - June 2024)

-   MIMU Peacebuilding Countrywide Dataset

-   MIMU Protection Countrywide Dataset

### Geospatial

The following datasets were obtained from: <https://data.humdata.org/organization/mimu>

-   Myanmar Country Boundaries MIMU

-   Myanmar District Boundarie

-   Points of Interest from **OpenStreetMap,** depicting different categories of features mapped by the OSM community. It depicts various categories such as : public services and infrastructure, emergency and safety locations, amenities and

This additional dataset from OpenStreetMap is crucial for analyzing armed conflict in Myanmar as it provides detailed geographic information on key locations such as public services, infrastructure, and emergency and safety sites. Understanding the distribution of these points of interest helps in assessing the impact of conflict on civilian infrastructure, access to essential services, and the safety of affected populations. Furthermore, it may aid in planning humanitarian assistance, evacuation routes, and monitoring areas of strategic importance during the conflict through data insights.

For the purposes of this exercise, we will focus on the State/Region boundaries, seeing as the conflict is generally explored in this manner (as inferred from the given references in the Take Home Exercise Overview). This is represented by the first administrative level (admin1). Myanmar is divided into 7 states and 7 regions (plus the Union Territory of Naypyidaw).

These boundaries are politically and administratively significant. Different **states** (e.g., Kachin, Rakhine, Shan) and **regions** have distinct ethnic compositions and different conflict dynamics, making this level critical for understanding broader conflict patterns.

# 3.0 Geospatial Data Wrangling

## 3.1 Importing Spatial Data

### 1. Myanmar CSV

Using read_csv to import the data in the `MYANMAR.CSV` file, which is the ACLED Dataset detailing armed conflict in Myanmar:

```{r}
armed_conflict_data <- read_csv("data/aspatial/2021-01-01-2024-06-30-Myanmar.csv")
```

Check and transform the CRS of the ACLED Dataset

```{r}
armed_conflict_sf <- st_as_sf(armed_conflict_data, coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(armed_conflict_sf, crs=32647)
```

```{r}
st_crs(armed_conflict_sf)
```

### 2. Country, State, Region, District & Township Boundaries

Using the st_read function, we will import data from the State & Region Sub-boundary dataset to visualize Myanmar's landscape:

```{r}
state_region_sf <-  st_read(dsn="data/geospatial/stateRegion", layer 
="mmr_polbnda_adm1_250k_mimu_1") %>% 
  st_transform(myanmar_sf, crs=32647)
```

From here on out, we will denote points-of-interest as POI.

I will load the corresponding shapefile:

```{r}
poi_sf <- st_read(dsn = "data/geospatial/pointsOfInterest", layer = "hotosm_mmr_points_of_interest_points_shp") %>%
  st_set_crs(4326) %>%  
  st_transform(crs = 32647)  
```

After importing the dataset, we will plot to see the boundaries of the State & Regions of Myanmar. The **`plot()`** function is used to plot the geometry of the **`sf`** object. The **`st_geometry()`** function is used to extract the geometry of the **`state_region_sf`** object.

```{r fig.width=12, fig.height=10}
par(mar = c(0,0,0,0))
plot(st_geometry(state_region_sf))

centroids <- st_centroid(state_region_sf)
coords <- st_coordinates(centroids)
text(x = coords[,1], y=coords[,2], labels = state_region_sf$ST, cex=0.9, )
```

## 3.2 Data Preparation

Before a thematic map can be prepared, we have to prepare a data table which includes the variables event types, focused on : Battles, Explosion/Remote violence, Strategic developments, and Violence against civilians.

```{r}
str(armed_conflict_sf)
```

Here is a visual overview of the 4 different types of Armed Conflict (based on event_types) :

```{r}
ggplot()+ 
  geom_sf(data = state_region_sf, color='black') + 
  geom_sf(data = armed_conflict_sf, aes(color=event_type), size=0.5, alpha=0.5) + 
  scale_color_brewer(palette = "Set1")
  labs(title="Armed Conflict in Myanmar (Jan 2021 - Jun 2024)",
       x = "Longitude", 
       y = "Latitude", 
       color = "Event Type") + 
  theme_minimal()
```

```{r fig.width=12, fig.height=10}
ggplot() + 
  geom_sf(data = state_region_sf, color = 'black') + 
  geom_sf(data = armed_conflict_sf, aes(color = event_type), size = 0.001, alpha = 0.5) + 
  scale_color_brewer(palette = "Set1") +
  labs(title = "Armed Conflict in Myanmar (Jan 2021 - Jun 2024)",
       x = "Longitude", 
       y = "Latitude", 
       color = "Event Type") + 
  theme_minimal() +
  facet_wrap(~event_type)  
```

From the plots above, we see that armed conflict even types seem to concentrate in the North-west region, particularly at the boundary of Sagaing, Mandalay and Magwe state.

In order to group and have a sensing of the effects of armed conflict, we will aggregate based on fatalities to see a quick overview as well as their state (administrative boundary 1) :

```{r}
armed_conflict_fatalities <- armed_conflict_sf %>% 
  group_by(admin1, event_type) %>% 
  summarize(total_fatalities = sum(fatalities, na.rm=TRUE)) %>% 
  ungroup() %>% 
  
  #Summarize fatalities based on the administrative boundary (stateRegion)
  group_by(admin1) %>% 
  mutate(total_fatalities_admin1 = sum(total_fatalities)) %>% 
  ungroup() %>% 
  
  #Arrange admin1 by descending order of fatalities and then the event type 
  arrange(desc(total_fatalities_admin1), admin1, desc(total_fatalities)) 

armed_conflict_fatalities
```

We'll now process the data to see the corresponding fatalities with the different event types mentioned above, **Battles, Explosions/Remote violence, Strategic developments and Violence against civilians**:

-   Since we are interested in deriving the quarterly KDE layers, we will convert the event_date column (currently in \[chr\] format), into a Date object that can be used for further analysis.

```{r}
armed_conflict_quartered <- armed_conflict_sf %>% 
  mutate(event_date = as.Date(event_date, format = "%d %B %Y")) %>% 
  mutate(quarter = paste0("Q", quarter(event_date), " ", year(event_date))) %>% 
  group_by(quarter, event_type, geometry, admin1) %>% 
  summarize(
      `FATALITIES` = sum(fatalities, na.rm=TRUE), 
      event_count = n()
  ) %>% 
  ungroup()
```

The code chunk below saves the intermediate dataset:

```{r}

file_path <- "data/aspatial/armed_conflict_quartered.csv"

if (!file.exists(file_path)) {
  write.csv(armed_conflict_quartered, file_path, row.names = FALSE)
  cat("File saved as", file_path, "\n")
} else {
  cat("File", file_path, "already exists. Skipping save operation.\n")
}
```

## 3.3 Converting sf Object to sp Object

```{r}
armed_conflict_sp <- as(armed_conflict_quartered, "Spatial")
state_region_sp <- as(state_region_sf, "Spatial")
```

```{r}
# Count distinct geometries (unique coordinates)
unique_coordinates <- armed_conflict_quartered %>%
  summarise(unique_count = n_distinct(geometry))

# Count distinct event IDs
unique_event_id_count <- armed_conflict_sf %>%
  summarize(unique_geom = n_distinct(event_id_cnty))

# Print the results
print(unique_coordinates)  # View the count of unique geometries
print(unique_event_id_count)  # View the count of unique event IDs
```

## 3.4 Converting sp Object to spatstat's ppp Format

```{r}
armed_conflict_ppp <- as.ppp(st_coordinates(armed_conflict_quartered), st_bbox(armed_conflict_quartered))

armed_conflict_ppp <- as.ppp(armed_conflict_quartered)
```

**Warning: (Regarding duplicates)** In spatial point patterns analysis an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are *simple*, that is, that the points cannot be coincident.

# 4.0 Handling duplicated points

We check for duplication in the ppp object using the code chunk below. Before processing, we need to account for the fact that we have divided the data into quarters, which would result in the event_types at the same location being treated as separate points, but spatstat recognizing them as duplicates as they share the exact same coordinates.

```{r}
any(duplicated(armed_conflict_ppp))
```

```{r}
sum(multiplicity(armed_conflict_ppp) > 1)
```

Why are there so many duplicates out of 24,216 observations?

1.  **Multiple Events Occurring at the Same Location**
2.  **Spatial Granularity**
3.  **Time Dimension is Not Considered in Duplicates**:

Based on the analysis of unique coordinate points earlier, the unique coordinates total to 7416 unique locations within the initial dataset, so the `sum(multiplicity(armed_conflict_ppp) > 1)` result is actually misleading as it may be accounting for events across time in the same coordinate location.

To account for the number of locations which have more than one point event, we can use the code chunk below:

```{r}
coords <- st_coordinates(armed_conflict_sf)
coords_df <- as.data.frame(coords)

location_counts <- coords_df %>% 
  group_by(X,Y) %>% 
  summarize(count = n()) %>% 
  ungroup()

locations_with_multiple_events <- location_counts %>% 
  filter(count > 1)

count_locations_with_multiple_events <- nrow(locations_with_multiple_events)
count_locations_with_multiple_events
```

Out of 7416 unique coordinate points, 4118 have more than one conflict events occuring throughout the time period of Jan 2021 - Jun 2024.

```{r}
tmap_mode('view')

tm_shape(armed_conflict_quartered) + 
  tm_dots(alpha = 0.7, size = 0.01)
```

```{r}
tmap_mode('plot')
```

## 4.1 Spotting Duplicate points from the map shown

To address the duplicate points, which largely arises due to the temporal aspect of the different violence types happening throughout the years, we will use Jittering (adding a small perturbation to the duplicate points so that they do not occupy the exact same space)

The code chunk below implements the jittering approach.

```{r}
armed_conflict_jitter <- rjitter(armed_conflict_ppp, 
                                 retry=TRUE, 
                                 nsim=1, 
                                 drop=TRUE)
```

Check for duplicated points in the data:

```{r}
any(duplicated(armed_conflict_jitter))
```

# 5.0 Creating *owin* object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Myanmar boundary. In **spatstat**, an object called ***owin*** is specially designed to represent this polygonal region.

The code chunk below is used to covert state_Region SpatialPolygon object into owin object of **spatstat:**

```{r}
myanmar_states_owin <- as.owin(state_region_sf)
```

```{r}
class(myanmar_states_owin)
```

The output object can be displayed by using plot():

```{r}
plot(myanmar_states_owin)
```

```{r}
summary(myanmar_states_owin)
```

# 6.0 Combining point events object and owin object

In the next step of geospatial data wrangling, we extract armed conflict events located within Myanmar using this code chunk:

```{r}
armed_conflict_myn_ppp <- armed_conflict_ppp[myanmar_states_owin]
```

The output combined both the point and polygon feature in one ppp object class as shown below:

```{r}
plot(armed_conflict_myn_ppp, cex = 0.4, main="Spatial Distribution of Armed Conflict in Myanmar")
```

The code chunk further dissects the distribution according time:

```{r}
quarters <- unique(armed_conflict_quartered$quarter)

par(mfrow = c(2,4), mar=c(2,2,2,2))

for (q in quarters){
  quarter_subset <- armed_conflict_quartered %>% 
    filter(quarter == q)
  
  armed_conflict_quarter_ppp <- as.ppp(st_coordinates(quarter_subset), W = st_bbox(quarter_subset))
  
  armed_conflict_myn_ppp <- armed_conflict_quarter_ppp[myanmar_states_owin]
  plot(armed_conflict_myn_ppp, cex = 0.2, main = paste(q))
  plot(myanmar_states_owin, add=TRUE)
}
```

# 7.0 1st Order Spatial Point Pattern Analysis

## 7.1 Kernel Density Estimation

This section with perform first-order SPPA and focus on :

1.  Deriving KDE for visualizing and exploring the intensity of point processes
2.  Perform Confirmatory Spatial Point Patterns Analysis by using Nearest Neighbour Statistics

### 7.1.1 Computing KDE using automatic bandwidth selection method

The code chunk below computes a kernel density by using the following configurations of [*density()*](https://rdrr.io/cran/spatstat/man/density.ppp.html) of **spatstat**:

-   [*bw.diggle()*](https://rdrr.io/cran/spatstat/man/bw.diggle.html) automatic bandwidth selection method. Other recommended methods are [*bw.CvL()*](https://rdrr.io/cran/spatstat/man/bw.CvL.html), [*bw.scott()*](https://rdrr.io/cran/spatstat/man/bw.scott.html) or [*bw.ppl()*](https://rdrr.io/cran/spatstat/man/bw.ppl.html).

-   The smoothing kernel used is *gaussian*, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.

```{r}
kde_armed_conflict_myn_bw <- density(armed_conflict_myn_ppp, 
                                     sigma=bw.diggle, 
                                     edge=TRUE,
                                     kernel="gaussian")
```

```{r}
plot(kde_armed_conflict_myn_bw)
```

```{r}
sigma_diggle <- bw.diggle(armed_conflict_myn_ppp)
sigma_diggle
```

### 7.1.2 Rescalling KDE values

In the code chunk below, we need to rescale.ppp() unit from meter to kilometer to prevent interference in the scale as well as the distortion of the bandwith values:

```{r}
armed_conflict_myn_ppp.km <- rescale.ppp(armed_conflict_myn_ppp, 1000, "km")
```

We re-run density() using the rescaled data and plot the output KDE map: (Note the difference between \_bw and .bw to denote scaled data)

```{r}
kde_armed_conflict_myn.bw <- density(armed_conflict_myn_ppp.km,
                                     sigma=bw.diggle, 
                                     edge=TRUE, 
                                     kernel="gaussian")

plot(kde_armed_conflict_myn.bw)
```

```{r}
sigma_diggle <- bw.diggle(armed_conflict_myn_ppp.km)
sigma_diggle
```

# 8.0 Comparing Spatial Point Patterns across Quarterly KDEs

## 8.1 Fixed vs Adaptive KDE

The choice between automatic and adaptive bandwidth depends on the objectives and nature of our analysis.

+---------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Automatic Bandwidth                                                                               | Adaptive Bandwidth                                                                                                                                                     |
+===================================================================================================+========================================================================================================================================================================+
| Offers Consistency across Space: Uniform smoothing across the entire study area.                  | Varying Spatial Densities: Showing significant differences in conflict event densities (urban, rural ares), adaptive bandwidth could give a more nuanced understanding |
+---------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| General Hotspot Detection: To identify overall hotspots or conflict zones without too much detail | Local Hotspot Detection                                                                                                                                                |
+---------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

For the following sections, we will compare the KDE of Armed Conflict Event_Types in Myanmar over the quarters of Jan 2021 - Jun 2024.

## 8.2 Extracting Study Areas

```{r}
armed_conflict_fatalities %>% 
  dplyr::select(admin1, total_fatalities_admin1)
```

We can create a vector of the quarter time period and use the functions lapply() (or purrr::map()) to filter and select the data for each quarter, storing the results in a list:

```{r}
#2021 
q1_2021 <- armed_conflict_quartered %>% 
  filter(quarter == "Q1 2021") %>% 
  dplyr::select(event_type, geometry)

q2_2021 <- armed_conflict_quartered %>% 
  filter(quarter == "Q2 2021")  %>% 
  dplyr::select(event_type, geometry)
  
q3_2021 <- armed_conflict_quartered %>% 
  filter(quarter == "Q3 2021")  %>% 
  dplyr::select(event_type, geometry)
  
q4_2021 <- armed_conflict_quartered %>% 
  filter(quarter == "Q3 2021")  %>% 
  dplyr::select(event_type, geometry)

#2022
q1_2022 <- armed_conflict_quartered %>% 
  filter(quarter == "Q1 2022")  %>% 
  dplyr::select(event_type, geometry)

q2_2022 <- armed_conflict_quartered %>% 
  filter(quarter == "Q2 2022")  %>% 
  dplyr::select(event_type, geometry)
  
q3_2022 <- armed_conflict_quartered %>% 
  filter(quarter == "Q3 2022")  %>% 
  dplyr::select(event_type, geometry)
  
q4_2022 <- armed_conflict_quartered %>% 
  filter(quarter == "Q3 2022")  %>% 
  dplyr::select(event_type, geometry)

#2023
q1_2023 <- armed_conflict_quartered %>% 
  filter(quarter == "Q1 2023")  %>% 
  dplyr::select(event_type, geometry)

q2_2023 <- armed_conflict_quartered %>% 
  filter(quarter == "Q2 2023")  %>% 
  dplyr::select(event_type, geometry)
  
q3_2023 <- armed_conflict_quartered %>% 
  filter(quarter == "Q3 2023")  %>% 
  dplyr::select(event_type, geometry)
  
q4_2023 <- armed_conflict_quartered %>% 
  filter(quarter == "Q3 2023")  %>% 
  dplyr::select(event_type, geometry)


#2022
q1_2024 <- armed_conflict_quartered %>% 
  filter(quarter == "Q1 2024")  %>% 
  dplyr::select(event_type, geometry)

q2_2024 <- armed_conflict_quartered %>% 
  filter(quarter == "Q2 2024")  %>% 
  dplyr::select(event_type, geometry)
```

Plotting the armed_conflict by quarter :

```{r}
armed_conflict_quartered
```

```{r}
armed_conflict_fatalities
```

```{r}
ggplot(armed_conflict_quartered, aes(x = FATALITIES, 
                                     y = factor(quarter, levels = sort(unique(quarter))), fill = event_type)) + 
  geom_bar(stat = "identity", position = "dodge") + 
  labs(title = "Total Fatalities by Event Type per Quarter", 
       x = "Fatalities", 
       y = "Quarter", 
       fill = "Event Type") + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
colnames(armed_conflict_quartered)
```

```{r}
par(mfrow=c(2,2))
#2021 Plots 
plot(q1_2021, main="Q1 2021")
plot(q2_2021, main="Q2 2021")
plot(q3_2021, main="Q3 2021")
plot(q3_2021, main="Q4 2021")

#2022 Plots 
plot(q1_2022, main="Q1 2022")
plot(q2_2022, main="Q2 2022")
plot(q3_2022, main="Q3 2022")
plot(q3_2022, main="Q4 2022")

#2023 Plots 
plot(q1_2023, main="Q1 2023")
plot(q2_2023, main="Q2 2023")
plot(q3_2023, main="Q3 2023")
plot(q3_2023, main="Q4 2023")

#2024 Plots
plot(q1_2024, main="Q1 2024")
plot(q2_2024, main="Q2 2024")
```

Our owin object:

```{r}
plot(myanmar_states_owin)
```

## 8.4 Computing Quarterly KDE

By using the code chunk below, we can extract the armed_conflict points using the quarter marks to proceed with analysis. Additionally, we have to

-   combine the myanmar_states_owin object and

-   rescale the data as done previously

```{r}
par(mfrow=c(2,2))

#2021 - Subset Armed Conflict Jitter
q1_2021_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q1 2021"]
q2_2021_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q2 2021"]
q3_2021_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q3 2021"]
q4_2021_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q4 2021"]

#2022 -Subset Armed Conflict Jitter
q1_2022_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q1 2022"]
q2_2022_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q2 2022"]
q3_2022_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q3 2022"]
q4_2022_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q4 2022"]

#2023 - Subset Armed Conflict Jitter 
q1_2023_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q1 2023"]
q2_2023_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q2 2023"]
q3_2023_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q3 2023"]
q4_2023_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q4 2023"]

#2024 - Subset Armed Conflict Jitter 
q1_2024_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q1 2024"]
q2_2024_jitter <- armed_conflict_jitter[armed_conflict_jitter$marks == "Q2 2024"]
```

### 8.4.1 Combining Quarterly Armed Conflict Points and with the owin Object

```{r}
# Subset jittered points by the Myanmar window (myanmar_states_owin)
# For 2021
q1_2021_ppp <- q1_2021_jitter[myanmar_states_owin]
q2_2021_ppp <- q2_2021_jitter[myanmar_states_owin]
q3_2021_ppp <- q3_2021_jitter[myanmar_states_owin]
q4_2021_ppp <- q4_2021_jitter[myanmar_states_owin]

# For 2022
q1_2022_ppp <- q1_2022_jitter[myanmar_states_owin]
q2_2022_ppp <- q2_2022_jitter[myanmar_states_owin]
q3_2022_ppp <- q3_2022_jitter[myanmar_states_owin]
q4_2022_ppp <- q4_2022_jitter[myanmar_states_owin]

# For 2023
q1_2023_ppp <- q1_2023_jitter[myanmar_states_owin]
q2_2023_ppp <- q2_2023_jitter[myanmar_states_owin]
q3_2023_ppp <- q3_2023_jitter[myanmar_states_owin]
q4_2023_ppp <- q4_2023_jitter[myanmar_states_owin]

# For 2024
q1_2024_ppp <- q1_2024_jitter[myanmar_states_owin]
q2_2024_ppp <- q2_2024_jitter[myanmar_states_owin]

```

### 8.4.2 Rescale.ppp()

```{r}
# For 2021
q1_2021_ppp.km = rescale.ppp(q1_2021_ppp, 1000, "km")
q2_2021_ppp.km = rescale.ppp(q2_2021_ppp, 1000, "km")
q3_2021_ppp.km = rescale.ppp(q3_2021_ppp, 1000, "km")
q4_2021_ppp.km = rescale.ppp(q4_2021_ppp, 1000, "km")

# For 2022
q1_2022_ppp.km = rescale.ppp(q1_2022_ppp, 1000, "km")
q2_2022_ppp.km = rescale.ppp(q2_2022_ppp, 1000, "km")
q3_2022_ppp.km = rescale.ppp(q3_2022_ppp, 1000, "km")
q4_2022_ppp.km = rescale.ppp(q4_2022_ppp, 1000, "km")

# For 2023
q1_2023_ppp.km = rescale.ppp(q1_2023_ppp, 1000, "km")
q2_2023_ppp.km = rescale.ppp(q2_2023_ppp, 1000, "km")
q3_2023_ppp.km = rescale.ppp(q3_2023_ppp, 1000, "km")
q4_2023_ppp.km = rescale.ppp(q4_2023_ppp, 1000, "km")

# For 2024
q1_2024_ppp.km = rescale.ppp(q1_2024_ppp, 1000, "km")
q2_2024_ppp.km = rescale.ppp(q2_2024_ppp, 1000, "km")
```

In the code chunk below, we will compute the KDE of each quarter of each year. ***bw.diggle*** method is used to derive the bandwidth of each KDE:

```{r}
par(mfrow=c(2,2))
plot(density(q1_2021_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q1 2021")

plot(density(q2_2021_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q2 2021")

plot(density(q3_2021_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q3 2021")

plot(density(q4_2021_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q4 2021")

#2022
par(mfrow=c(2,2))
plot(density(q1_2022_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q1 2022")

plot(density(q2_2022_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q2 2022")

plot(density(q3_2022_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q3 2022")

plot(density(q4_2022_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q4 2022")

#2023
par(mfrow=c(2,2))
plot(density(q1_2023_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q1 2023")

plot(density(q2_2023_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q2 2023")

plot(density(q3_2023_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q3 2023")

plot(density(q4_2023_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q4 2023")


#2024
par(mfrow=c(1,2))
plot(density(q1_2024_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q1 2024")

plot(density(q2_2024_ppp.km, 
             sigma=bw.diggle,
             edge=TRUE,
             kernel="gaussian"), 
     main="Q2 2024")
```

# 9.0 Nearest Neighbours Analysis:

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using [*clarkevans.test()*](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **statspat**.

The test hypotheses are:

Ho = The distribution of armed_conflict are randomly distributed.

H1= The distribution of armed_conflict are not randomly distributed.

The 95% confident interval will be used.

## 9.1 Testing Spatial Point Patterns using Clark and Evans Test

```{r}
clarkevans.test(armed_conflict_myn_ppp.km,
                correction="none",
                clipregion="myanmar_states_owin",
                alternative=c("two.sided"),
                nsim=99)
```

### 9.1.1 Clark and Evans Test: Q1 2021

```{r}
clarkevans.test(q1_2021_ppp.km, 
                correction="none", 
                clipregion="myanmar_states_owin", 
                alternative=c("two.sided"), 
                nsim=999)
```

### 9.1.2 Clark and Evans Test: Q1 2022

```{r}
clarkevans.test(q1_2022_ppp.km, 
                correction="none", 
                clipregion="myanmar_states_owin", 
                alternative=c("two.sided"), 
                nsim=999)
```

### 9.1.3 Clark and Evans Test: Q1 2023

```{r}
clarkevans.test(q1_2023_ppp.km, 
                correction="none", 
                clipregion="myanmar_states_owin", 
                alternative=c("two.sided"), 
                nsim=999)
```

### 9.1.4 Clark and Evans Test: Q1 2024

```{r}
clarkevans.test(q1_2024_ppp.km, 
                correction="none", 
                clipregion="myanmar_states_owin", 
                alternative=c("two.sided"), 
                nsim=999)
```

# 10.0 2nd Order Spatial Point Patterns Analysis

## 10.1 Analysing Spatial Point Process using G-Function

The code chunk below is used to compute G-function using *Gest()* of **spatat** package.

### 10.1.2 Computing G-Function Estimation

Q1_2021:

```{r}
G_Q1_2021 <- Gest(q1_2021_ppp, correction="border")
plot(G_Q1_2021)
```

Q1_2024:

```{r}
G_Q1_2024 <- Gest(q1_2024_ppp, correction="border")
plot(G_Q1_2024)
```

### 10.1.2 Performing Complete Spatial Randomness Test

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of armed conflict in Myanmar are randomly distributed.

H1= The distribution of armed conflict in Myanmar are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with G-function:

```{r}
G_Q1_2021.csr <- envelope(q1_2021_ppp, Gest, nsim=99)
```

```{r}
plot(G_Q1_2021.csr)
```

Q1_2024:

```{r}
G_Q1_2024.csr <- envelope(q1_2024_ppp, Gest, nsim=99)
```

```{r}
plot(G_Q1_2024.csr)
```

## 10.2 Analysing Spatial Point Process using F-Function

#### 10.2.1 Computing F-function estimation

```{r}
F_Q1_2021 = Fest(q1_2021_ppp, correction="best")
plot(F_Q1_2021)
```

#### 10.2.2 **Performing Complete Spatial Randomness Test**

```{r}
F_Q1_2021.csr <- envelope(q1_2021_ppp, Fest, nsim=99)
```

```{r}
plot(F_Q1_2021.csr)
```

## 10.3 Analysing Spatial Point Process using K-Function

#### 10.3.1 Computing K-function estimation

```{r}
K_Q1_2021 <- Kest(q1_2021_ppp, correction="Ripley")
plot(K_Q1_2021, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

#### 10.3.2 **Performing Complete Spatial Randomness Test**

```{r}
K_Q1_2021.csr <- envelope(q1_2021_ppp, Kest, nsim=99, rank=1, glocal=TRUE )
```

```{r}
plot(K_Q1_2021.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

## 10.4 Analysing Spatial Point Process using L-Function

#### 10.4.1 Computing L-function estimation

```{r}
L_Q1_2021 <- Lest(q1_2021_ppp, correction = "Ripley")
plot(L_Q1_2021, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

#### 10.4.2 **Performing Complete Spatial Randomness Test**

```{r}
L_Q1_2021.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_Q1_2021.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

# X.0 Additional Analysis

Due to the humanitarian casualties involved in the ongoing armed conflict, something interesting to explore is how some points of interest (particularly hospitals, shelters, police stations) are relevant to the conflict.

In the analysis of news articles by The Irrawaddy, a journalistic publication covering Myanmar and Southeast Asian news (with a Left-Center Bias, and CNN, there are claims that the Military Junta has been deliberately bombing Hospitals and other similar institutions aiming to provide afflicted civilians with aid. With the quarterly KDE we have derived earlier, it may serve as useful to see the proximity of these points of interest to clustered armed conflict zones. Additionally, we will focus our analysis on 3 primary states: Sagaing, Magway and Mandalay

```{r}
armed_conflict_fatalities
```
