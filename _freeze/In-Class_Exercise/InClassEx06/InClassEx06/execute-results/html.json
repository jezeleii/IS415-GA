{
  "hash": "e90c87e6fe4233e65951e2024d50c830",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class Exercise 06\"\nauthor: \"Jezelei Manangan\"\ndate: \"September 23, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n# 1.0 Objective & Overview\n\nBy the end to this in-ckass exercise, you will be able to:\n\n-   import geospatial data using appropriate function(s) of **sf** package,\n\n-   import csv file using appropriate function of **readr** package,\n\n-   perform relational join using appropriate join function of **dplyr** package,\n\n-   compute spatial weights using appropriate functions of **spdep** package, and\n\n-   calculate spatially lagged variables using appropriate functions of **spdep** package.\n\n-   GWModel\n\n# 2.0 The Study Area and Data\n\nTwo data sets will be used in this hands-on exercise, they are:\n\n-   Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\nBefore we get started, we need to ensure that **spdep**, **sf**, **tmap** and **tidyverse** packages of R are currently installed in your R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse)\n```\n:::\n\n\n## 2.1 **Import shapefile into R environment**\n\nThe code chunk below uses [`st_read()`](https://r-spatial.github.io/sf/reference/st_read.html) of **sf** package to import Hunan shapefile into R. The imported shapefile will be **simple features** Object of **sf**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\",\n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `/Users/jezelei/jezeleii/IS415-GA/In-Class_Exercise/InClassEx06/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n## 2.2 Import csv file into R environment\n\nNext, we will import *Hunan_2012.csv* into R by using [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.html) of **readr** package. The output is R data frame class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(hunan2012)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"County\"      \"City\"        \"avg_wage\"    \"deposite\"    \"FAI\"        \n [6] \"Gov_Rev\"     \"Gov_Exp\"     \"GDP\"         \"GDPPC\"       \"GIO\"        \n[11] \"Loan\"        \"NIPCR\"       \"Bed\"         \"Emp\"         \"EmpR\"       \n[16] \"EmpRT\"       \"Pri_Stu\"     \"Sec_Stu\"     \"Household\"   \"Household_R\"\n[21] \"NOIP\"        \"Pop_R\"       \"RSCG\"        \"Pop_T\"       \"Agri\"       \n[26] \"Service\"     \"Disp_Inc\"    \"RORP\"        \"ROREmp\"     \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NAME_2\"     \"ID_3\"       \"NAME_3\"     \"ENGTYPE_3\"  \"Shape_Leng\"\n[6] \"Shape_Area\" \"County\"     \"geometry\"  \n```\n\n\n:::\n:::\n\n\n## 2.3 Performing Relational Join\n\nThe code chunk below will be used to update the attribute table of *hunan*’s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* dataframe. This is performed by using [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.html) of **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_GDPPC <- left_join(hunan,hunan2012) %>% \n  select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#hunan <- hunan %>% \n  #select(1:4, 7, 15)\n  #select(1:4, 7, 15, 16, 31, 32, 33)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(hunan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NAME_2\"     \"ID_3\"       \"NAME_3\"     \"ENGTYPE_3\"  \"Shape_Leng\"\n[6] \"Shape_Area\" \"County\"     \"geometry\"  \n```\n\n\n:::\n:::\n\n\n# 3.0 Global Measures of Spatial Autocorrelation\n\n## 3.1 **Computing Contiguity Spatial Weights**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- hunan_GDPPC %>% \n  mutate(nb = st_contiguity(geometry), \n         wt = st_weights(nb, style=\"W\"),.before = 1)\n```\n:::\n\n\n\\*st_weights provide tree arguments :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 88 features and 8 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\nFirst 10 features:\n                               nb\n1                 2, 3, 4, 57, 85\n2               1, 57, 58, 78, 85\n3                     1, 4, 5, 85\n4                      1, 3, 5, 6\n5                     3, 4, 6, 85\n6                4, 5, 69, 75, 85\n7                  67, 71, 74, 84\n8       9, 46, 47, 56, 78, 80, 86\n9           8, 66, 68, 78, 84, 86\n10 16, 17, 19, 20, 22, 70, 72, 73\n                                                                            wt\n1                                                      0.2, 0.2, 0.2, 0.2, 0.2\n2                                                      0.2, 0.2, 0.2, 0.2, 0.2\n3                                                       0.25, 0.25, 0.25, 0.25\n4                                                       0.25, 0.25, 0.25, 0.25\n5                                                       0.25, 0.25, 0.25, 0.25\n6                                                      0.2, 0.2, 0.2, 0.2, 0.2\n7                                                       0.25, 0.25, 0.25, 0.25\n8  0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571, 0.1428571\n9             0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667, 0.1666667\n10                      0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125\n     NAME_2  ID_3    NAME_3   ENGTYPE_3    County GDPPC\n1   Changde 21098   Anxiang      County   Anxiang 23667\n2   Changde 21100   Hanshou      County   Hanshou 20981\n3   Changde 21101    Jinshi County City    Jinshi 34592\n4   Changde 21102        Li      County        Li 24473\n5   Changde 21103     Linli      County     Linli 25554\n6   Changde 21104    Shimen      County    Shimen 27137\n7  Changsha 21109   Liuyang County City   Liuyang 63118\n8  Changsha 21110 Ningxiang      County Ningxiang 62202\n9  Changsha 21111 Wangcheng      County Wangcheng 70666\n10 Chenzhou 21112     Anren      County     Anren 12761\n                         geometry\n1  POLYGON ((112.0625 29.75523...\n2  POLYGON ((112.2288 29.11684...\n3  POLYGON ((111.8927 29.6013,...\n4  POLYGON ((111.3731 29.94649...\n5  POLYGON ((111.6324 29.76288...\n6  POLYGON ((110.8825 30.11675...\n7  POLYGON ((113.9905 28.5682,...\n8  POLYGON ((112.7181 28.38299...\n9  POLYGON ((112.7914 28.52688...\n10 POLYGON ((113.1757 26.82734...\n```\n\n\n:::\n:::\n\n\n## Computing Global Moran'I\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI <- global_moran(wm_q$GDPPC, \n                       wm_q$nb, \n                       wm_q$wt)\n                       \nglimpse(moranI)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ I: num 0.301\n $ K: num 7.64\n```\n\n\n:::\n:::\n\n\n## Performing Global Moran'I test\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$GDPPC, \n                  wm_q$nb, \n                  wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n-   p-value : smaller than 0.05. There is enough statistical evidence, 95% confident we can reject the null hypothesis where the observed distribution does not conform to the random distribution\n\n-   Positive Moran I statistic -\\> sign of clustering, however at 0.3. It is a relatively low clustering\n\n-   K -\\> Average Value of K-Neighbours found\n\n## Performing Global Moran'I permutation test\n\nIt is always good to use set.seed() before performing simulation. This is to ensure reproducible computation. You can initialize this from the start\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$GDPPC, \n                  wm_q$nb, \n                  wm_q$wt, \n                nsim = 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n\n\n:::\n:::\n\n\n-   n=99sim == 100 iterations.\n\n-   The result will be the same.\n\n-   Interpretation of the p-value: Roughly 0.3 Moran –\\> stable result compared to the earlier calculation\n\n# Local\n\n## Computing Local Moran'I\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>% \n  mutate(local_moran = local_moran(\n    GDPPC, nb, wt, nsim=99),\n    .before = 1) %>% \n  unnest(local_moran)\n```\n:::\n\n\nUnnest() to put back into 1 single tibble table ( 1 - Many ) – You want to make it to one single table, without it, it can't be seen as a data frame\n\nBased on the dataframe results :\n\n-   ii -\\> local moran I\n\nP-VALUES\n\n-   p_ii, p_ii_sim, p_folded_sim\n\n    -   p_ii -\\> base method\n\n    -   p_ii -\\> simulation method\n\n    -   p_folded_sim (pysal method) - using K4 (take out one and leave out 1)\n\n-   use p_ii_sim (simulated)\n\nMEAN, MEDIAN, PYSAL\n\n-   Label Low-Low, High-High & 2 other\n\n-   Compared to Hands-on 6 (you have to manually generate low-low, high-high categorization)\n\n    -   excessive skewness (better to use the median)\n\n    -   if closer to 0 , use mean\n\n-   How do you determine closeness to 0? Very few of them near to 0 -\\> Know by plotting it out on a histogram – **refer to skewness as a factor**\n\n    -   no one-row, need to check the majority of the data and go by a mean or median (stay with one based on a classification method)\n\n## Visualizing local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\nmap1 <- tm_shape(lisa) + \n  tm_fill(\"ii\") + \n  tm_borders(alpha = 0.5) + \n  tm_view(set.zoom.limits = c(6,8)) + \n  tm_layout(\n    main.title = \"local Moran's I of GDPPC\", \n    main.title.size = 2)\n\nmap1\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nVariable(s) \"ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](InClassEx06_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## Visualizing p-value of local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\nmap2 <- tm_shape(lisa) + \n  tm_fill(\"p_ii_sim\") + \n  tm_borders(alpha = 0.5) + \n  tm_view(set.zoom.limits = c(6,8)) + \n  tm_layout(\n    main.title = \"local Moran's I of GDPPC\", \n    main.title.size = 2)\n\nmap2\n```\n\n::: {.cell-output-display}\n![](InClassEx06_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nNotice that the p value is all over the place, **ideally you need to scale it**\n\n## Visualizing local Moran's I and p-value\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntmap_arrange(map1, map2, ncol=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nVariable(s) \"ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](InClassEx06_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n## Visualizing LISA Map \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa %>% \n  filter(p_ii < 0.05)\n\ntmap_mode(\"plot\") + \n  tm_shape(lisa) + \n  tm_polygons() + \n  tm_borders(alpha=0.5) + \n  tm_shape(lisa_sig) + \n  tm_fill('mean') + \n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](InClassEx06_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\\*Take note: There is a p-value filter there\n\n-   purple - Low GDP area surrounded by high GDP area.\n\n\n```{=html}\n<!-- -->\n```\n\n-   Only see this because the rest are not statistically significant\n\n-   Area located near the province and the city - high growth area (Tiering of the Province; Ladder development)\n\n-   Growth spread from the capital (can explore factors accounting for this development)\n\n## Compute local Gi\\* statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw <- hunan_GDPPC %>% \n  mutate(nb = st_contiguity(geometry), \n         wts = st_inverse_distance(nb, geometry, \n                                   scale=1, \n                                   alpha=1), \n         .before =1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n! Polygon provided. Using point on surface.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `stopifnot()`.\nℹ In argument: `wts = st_inverse_distance(nb, geometry, scale = 1, alpha = 1)`.\nCaused by warning in `st_point_on_surface.sfc()`:\n! st_point_on_surface may not give correct results for longitude/latitude data\n```\n\n\n:::\n:::\n\n\n-   The wrapper - the one without the \\* (will exclude away the self item)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA <- wm_idw %>% \n  mutate(local_Gi = local_gstar_perm(\n    GDPPC, nb, wt, nsim =99),\n    .before=1) %>% \n  unnest(local_Gi)\nHCSA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 88 features and 18 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n# A tibble: 88 × 19\n   gi_star cluster   e_gi     var_gi std_dev p_value p_sim p_folded_sim skewness\n     <dbl> <fct>    <dbl>      <dbl>   <dbl>   <dbl> <dbl>        <dbl>    <dbl>\n 1  0.0416 Low     0.0114 0.00000641  0.0493 9.61e-1  0.7          0.35    0.875\n 2 -0.333  Low     0.0106 0.00000384 -0.0941 9.25e-1  1            0.5     0.661\n 3  0.281  High    0.0126 0.00000751 -0.151  8.80e-1  0.9          0.45    0.640\n 4  0.411  High    0.0118 0.00000922  0.264  7.92e-1  0.6          0.3     0.853\n 5  0.387  High    0.0115 0.00000956  0.339  7.34e-1  0.62         0.31    1.07 \n 6 -0.368  High    0.0118 0.00000591 -0.583  5.60e-1  0.72         0.36    0.594\n 7  3.56   High    0.0151 0.00000731  2.61   9.01e-3  0.06         0.03    1.09 \n 8  2.52   High    0.0136 0.00000614  1.49   1.35e-1  0.2          0.1     1.12 \n 9  4.56   High    0.0144 0.00000584  3.53   4.17e-4  0.04         0.02    1.23 \n10  1.16   Low     0.0104 0.00000370  1.82   6.86e-2  0.12         0.06    0.416\n# ℹ 78 more rows\n# ℹ 10 more variables: kurtosis <dbl>, nb <nb>, wts <list>, NAME_2 <chr>,\n#   ID_3 <int>, NAME_3 <chr>, ENGTYPE_3 <chr>, County <chr>, GDPPC <dbl>,\n#   geometry <POLYGON [°]>\n```\n\n\n:::\n:::\n\n\nHCSA\n\n-   gi_star, p_value, label (cluster) - statistics to take note of\n\nSimilar process to Moran'I \\| Gi\\* Statistic\n\nLISA - Cluster & Outliers\n\nGi\\* - Hot Spot & Cold Spot\n\n## Visualizing GI\\* - Hot Spot & Cold Spot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(HCSA) + \n  tm_fill(\"gi_star\") + \n  tm_borders(alpha = 0.5) + \n  tm_view(set.zoom.limits=c(6,8))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nVariable(s) \"gi_star\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](InClassEx06_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n## p-value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA_sig <- HCSA %>% \n  filter(p_sim < 0.05) \n\ntmap_mode('plot')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(HCSA) + \n  tm_polygons() + \n  tm_borders(alpha = 0.5) + \n  \ntm_shape(HCSA_sig) + \n  tm_fill(\"gi_star\") + \n  tm_borders(alpha=0.4)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nVariable(s) \"gi_star\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](InClassEx06_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n-   Can replace gi_star with cluster to visualize the clusters\n\n-   By right, you should map it back to the label\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA_sig <- HCSA %>% \n  filter(p_sim < 0.05) \n\ntmap_mode('plot')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(HCSA) + \n  tm_polygons() + \n  tm_borders(alpha = 0.5) + \n  \ntm_shape(HCSA_sig) + \n  tm_fill(\"cluster\") + \n  tm_borders(alpha=0.4)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](InClassEx06_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "InClassEx06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}