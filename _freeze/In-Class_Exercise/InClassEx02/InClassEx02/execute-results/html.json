{
  "hash": "a74c3bd4386d49ba25455c59813e9272",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 2\"\nauthor: \"Jezelei Manangan\"\ndate: r.sys.date()\ndate-modified: \"last-modified\"\nformat: html\neditor: visual\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n# 1.0 Getting started\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse,sf)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n# 2.0 Working with Master Plan Planning Sub-zone Data\n\nThis code chunk imports shapefile:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz14_shp <- st_read(dsn = \"data/\", layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/jezelei/jezeleii/IS415-GA/In-Class_Exercise/InClassEx02/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mpsz14_shp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"sf\"         \"data.frame\"\n```\n\n\n:::\n:::\n\n\nThis code chunk imports kml. However the file is corrupted. Take the shapefile accordingly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#mpsz14_kml <- st_read(\"data/MasterPlan2014SubzoneBoundaryWebKML.kml\")\nst_write(mpsz14_shp, \"data/MP14_SUBZONE_WEB_PL.kml\", \n                      delete_dsn = TRUE)\n```\n:::\n\n\nWhy does the code not work initially?\n\n:   The file is likely corrupted. To resolve this, take the shape file accordingly.\n\n    Futhermore, delete_dsn() is needed to check if the dataset exists if you are writing it over.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz14_kml <- st_read(\"data/MP14_SUBZONE_WEB_PL.kml\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/jezelei/jezeleii/IS415-GA/In-Class_Exercise/InClassEx02/data/MP14_SUBZONE_WEB_PL.kml' \n  using driver `KML'\nSimple feature collection with 323 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n## 2. 1 Importing Data from MPSZ_2019\n\nThis code chunk imports the MPSSZ-2019 shapefile:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz19_shp <- st_read(dsn = \"data/\", layer = \"MPSZ-2019\") %>% \n  st_transform(crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MPSZ-2019' from data source \n  `/Users/jezelei/jezeleii/IS415-GA/In-Class_Exercise/InClassEx02/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz19_kml <- st_read(\"data/MasterPlan2019SubzoneBoundaryNoSeaKML.kml\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `URA_MP19_SUBZONE_NO_SEA_PL' from data source \n  `/Users/jezelei/jezeleii/IS415-GA/In-Class_Exercise/InClassEx02/data/MasterPlan2019SubzoneBoundaryNoSeaKML.kml' \n  using driver `KML'\nSimple feature collection with 332 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY, XYZ\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\nThis code chunk imports the preschool data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npreschool <- st_read(\"data/PreSchoolsLocation.kml\") %>% \n  st_transform(crs = 3414)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `/Users/jezelei/jezeleii/IS415-GA/In-Class_Exercise/InClassEx02/data/PreSchoolsLocation.kml' \n  using driver `KML'\nSimple feature collection with 2290 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6878 ymin: 1.247759 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\nThis code chunk loads the population data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata <- read_csv(\"data/respopagesextod2023.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 100928 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nStep 1: Segregate the df showing the planning subzone and area\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2023 <- popdata %>% \n  group_by(PA, SZ, AG) %>% \n  summarise(`POP` = sum(`Pop`)) %>% \n  ungroup() %>% \n  pivot_wider(names_from=AG, values_from = POP)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n:::\n\n\nStep 1(a) : Alternative; Break down the code step by step:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Group By Function \npopdata_step1 <- popdata %>% \n  group_by(PA, SZ, AG) \n\n#Summarize & Ungroup Function \npopdata_step2 <- popdata_step1 %>% \n  summarise(`POP` = sum(`Pop`)) %>% \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\n#Pivot_Wider - transpose the selected columns \npopdata2023 <- popdata_step2 %>% \n  pivot_wider(names_from=AG, values_from = POP)\n```\n:::\n\n\n> Check the columns :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(popdata2023)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"PA\"          \"SZ\"          \"0_to_4\"      \"10_to_14\"    \"15_to_19\"   \n [6] \"20_to_24\"    \"25_to_29\"    \"30_to_34\"    \"35_to_39\"    \"40_to_44\"   \n[11] \"45_to_49\"    \"50_to_54\"    \"55_to_59\"    \"5_to_9\"      \"60_to_64\"   \n[16] \"65_to_69\"    \"70_to_74\"    \"75_to_79\"    \"80_to_84\"    \"85_to_89\"   \n[21] \"90_and_Over\"\n```\n\n\n:::\n:::\n\n\nProcess the code for popdata2023 :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2023 <- popdata2023 %>% \n  mutate(`YOUNG` = rowSums(.[3:6]) + rowSums(.[14])) %>% \n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:13]) + rowSums(.[15])) %>% \n  mutate(`AGED` = rowSums(.[16:21])) %>% \n  mutate(`TOTAL` = rowSums(.[3:21])) %>% \n  mutate(`DEPENDENCY` = (`YOUNG` + `AGED`) / `ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, `ECONOMY ACTIVE`, `AGED`, `TOTAL`, `DEPENDENCY`)\n```\n:::\n\n\nJoining popdata2023 and mpsz19_shp, we first convert the names to_upper(), as r is case sensitive.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2023 <- popdata2023 %>% \n  mutate_at(.vars = vars(PA,SZ), \n            .funs = list(toupper))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_pop2023 <- left_join(popdata2023, mpsz19_shp,\n                          by = c(\"SZ\" = \"SUBZONE_N\"))\n```\n:::\n\n\nThings to note:\n\n-   mutate_at vs mutate\n\n    -   mutate() allows you to create new variables for specific variables\n\n    -   mutate_at() allows to you to create new variables for a group of variables that match the criteria\n\n-   mpsz_pop2023 : conduct a left join where the 'left' dataset needs to contain the geometric dataset\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}